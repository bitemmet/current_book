<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Writing the physics simulator</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Writing the physics simulator</h1>
                </header>
            
            <article>
                
<p>The physics simulator in <kbd>src/physics.rs</kbd> is responsible for modeling the physics and layout of the building and elevator operations. The simulator will be provided with one object to handle motor control and another to handle data collection. The physics simulator module will define traits for each of those interfaces, and the motor control and data collection objects should implement each <kbd>trait</kbd>, respectively.</p>
<p>Let's start by defining some of the type declarations for the <kbd>physics</kbd> module. First, let's look at a key interface—the direct motor input. Until this point, we have assumed that motor input will have simple voltage control that we can represent as a positive or negative floating point integer. This definition is problematic, mainly in the sense that all references to this type will reference <kbd>f64</kbd>. This type specifies a very specific data representation with no room for adjustment. If we litter our code with references to this type, then any changes will require us to go back and edit every one of the references. </p>
<p>Instead, for the motor input type, let's provide a name for the type. This could be an alias for the <kbd>f64</kbd> type, which would solve the immediate concern. Though this is acceptable, we will choose to be even more explicit with the type definition and provide <kbd>enum</kbd> cases for up and down. The <kbd>enum</kbd> type, also known as a <strong>tagged union</strong>, is useful to define data that may have multiple structures or use cases. Here, the constructors are identical, but the meaning of each voltage field is opposite. </p>
<p><span>Furthermore, when interacting with the <kbd>MotorInput</kbd> type, we should avoid assuming any internal structure. This minimizes our exposure to future interface changes that may change because <kbd>MotorInput</kbd> defines an interface with a currently unknown physical component. We will be responsible for software compatibility with that interface. So, to abstract any interaction with <kbd>MotorInput</kbd>, we will use traits instead. Traits that do not define intrinsic behavior of a</span> type<span>, but rather associated behavior, are sometimes called <strong>data classes</strong>.</span></p>
<p><span>Here is the <kbd>enum</kbd> and a data class defining the calculation of force derived from an input:</span></p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub enum MotorInput<br/></span><span class="s1">{<br/></span><span class="s1">   Up { voltage: f64 },<br/></span><span class="s1">   Down { voltage: f64 }<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub trait MotorForce {<br/></span><span class="s1">   fn calculate_force(&amp;self) -&gt; f64;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl MotorForce for MotorInput {<br/></span><span class="s1">   fn calculate_force(&amp;self) -&gt; f64<br/></span><span class="s1">   {<br/></span><span class="s1">      match *self {<br/></span><span class="s1">         MotorInput::Up { voltage: v } =&gt; { v * 8.0 }<br/></span><span class="s1">         MotorInput::Down { voltage: v } =&gt; { v * -8.0 }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub trait MotorVoltage {<br/></span><span class="s1">   fn voltage(&amp;self) -&gt; f64;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl MotorVoltage for MotorInput {<br/></span><span class="s1">   fn voltage(&amp;self) -&gt; f64<br/></span><span class="s1">   {<br/></span><span class="s1">      match *self {<br/></span><span class="s1">         MotorInput::Up { voltage: v } =&gt; { v }<br/></span><span class="s1">         MotorInput::Down { voltage: v } =&gt; { -v }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span><span class="s1"> </span></pre>
<p>Next, let's define the elevator information. We will create an <kbd>ElevatorSpecification</kbd>, which describes the structure of the building and elevator. We also require an <kbd>ElevatorState</kbd> to hold information regarding the current elevator status. To clarify usage of floor requests, we will also create an alias for <kbd>FloorRequests</kbd> vectors to make the meaning explicit. We will choose to use a <kbd>struct</kbd> instead of tuples here to create explicit field names. Otherwise, structs and tuples are interchangeable for storing miscellaneous data. The definitions are as follows:</p>
<pre class="p1" style="padding-left: 30px">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorSpecification<br/>{<br/>   pub floor_count: u64,<br/>   pub floor_height: f64,<br/>   pub carriage_weight: f64<br/>}<br/><br/>#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorState<br/>{<br/>   pub timestamp: f64,<br/>   pub location: f64,<br/>   pub velocity: f64,<br/>   pub acceleration: f64,<br/>   pub motor_input: MotorInput<br/>}<br/><br/>pub type FloorRequests = Vec&lt;u64&gt;;</pre>
<p>The traits for <kbd>MotorController</kbd> and <kbd>DataRecorder</kbd> are almost identical. The only difference is that polling a <kbd>MotorController</kbd> expects a <kbd>MotorInput</kbd> to be returned. Here, we choose to use <kbd>init</kbd> methods instead of constructors to permit additional external initialization of each resource. For example, it may be necessary for <kbd>DataRecorder</kbd> to open files or other resources to be accessed during simulation. Here are the <kbd>trait</kbd> definitions:</p>
<pre class="p1" style="padding-left: 30px">pub trait MotorController<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState);<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64) -&gt; MotorInput;<br/>}<br/><br/>pub trait DataRecorder<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState);<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64);<br/>   fn summary(&amp;mut self);<br/>}</pre>
<p class="mce-root"><span>To simulate the physics of the elevator, we will reproduce the central loop of the simulation from <a href="bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml" target="_blank">Chapter 2</a>, <em>Functional Control Flow</em>. Some of the state has been organized into structures instead of loose variables. Motor control decisions have been delegated to the <kbd>MotorController</kbd> object. Output and data recording has been delegated to the <kbd>DataRecorder</kbd>. There is also a new parameter field to specify the elevator's carriage weight. With all of these generalizations, the code becomes as follows:</span></p>
<pre class="p1">pub fn simulate_elevator&lt;MC: MotorController, DR: DataRecorder&gt;(esp: ElevatorSpecification, est: ElevatorState, req: FloorRequests,<br/>                         mc: &amp;mut MC, dr: &amp;mut DR) {<br/><br/>   //immutable input becomes mutable local state<br/>   let mut esp = esp.clone();<br/>   let mut est = est.clone();<br/>   let mut req = req.clone();<br/><br/>   //initialize MotorController and DataController<br/>   mc.init(esp.clone(), est.clone());<br/>   dr.init(esp.clone(), est.clone());<br/><br/>   //5. Loop while there are remaining floor requests<br/>   let original_ts = Instant::now();<br/>   thread::sleep(time::Duration::from_millis(1));<br/>   while req.len() &gt; 0<br/>   {<br/>      //5.1. Update location, velocity, and acceleration<br/>      let now = Instant::now();<br/>      let ts = now.duration_since(original_ts)<br/>                  .as_fractional_secs();<br/>      let dt = ts - est.timestamp;<br/>      est.timestamp = ts;<br/><br/>      est.location = est.location + est.velocity * dt;<br/>      est.velocity = est.velocity + est.acceleration * dt;<br/>      est.acceleration = {<br/>         let F = est.motor_input.calculate_force();<br/>         let m = esp.carriage_weight;<br/>         -9.8 + F/m<br/>      };</pre>
<p>After declaring the state and calculating time-dependent variables, we add the elevator control logic:</p>
<pre class="p1">      //5.2. If next floor request in queue is satisfied, <br/>          then remove from queue<br/>      let next_floor = req[0];<br/>      if (est.location - (next_floor as f64)*esp.floor_height).abs() <br/>         &lt; 0.01 &amp;&amp;<br/>         est.velocity.abs() &lt; 0.01<br/>      {<br/>         est.velocity = 0.0;<br/>         req.remove(0);<br/>        //remove is an O(n) operation<br/>        //Vec should not be used like this for large data<br/>      }<br/><br/>      //5.4. Print realtime statistics<br/>      dr.poll(est.clone(), next_floor);<br/><br/>      //5.3. Adjust motor control to process next floor request<br/>      est.motor_input = mc.poll(est.clone(), next_floor);<br/><br/>      thread::sleep(time::Duration::from_millis(1));<br/>   }<br/>}</pre>


            </article>

            
        </section>
    </body>

</html>