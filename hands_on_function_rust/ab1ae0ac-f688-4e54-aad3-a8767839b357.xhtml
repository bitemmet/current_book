<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Using the functor pattern</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Using the functor pattern</h1>
                </header>
            
            <article>
                
<p>A functor is approximately the inverse of a function:</p>
<ul>
<li>A function defines a transformation, accepts data, and returns the result of the transformation</li>
<li>A functor defines data, accepts a function, and returns the result of the transformation</li>
</ul>
<p>A simple example of a functor is the Rust vector and its accompanying <kbd>map</kbd> function:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() {<br/>   let m: Vec&lt;u64&gt; = vec![1, 2, 3];<br/></span><span class="s1">   let n: Vec&lt;u64&gt; = m.iter().map(|x| { x*x }).collect();<br/></span><span class="s1">   println!("{:?}", m);<br/></span><span class="s1">   println!("{:?}", n);<br/>}</span></pre>
<p>Functors are often thought of as only the <kbd>map</kbd> function, due to the rules of what constitutes a functor or not. The preceding common case is what's called a <strong>structure-preserving map</strong>. Functors do not need to be structure-preserving. For example, take the very similar case of a map implemented for a set, as shown in the following code:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::collections::{HashSet};<br/><br/></span><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let mut a: HashSet&lt;u64&gt; = HashSet::new();<br/></span><span class="s1">   a.insert(1);<br/></span><span class="s1">   a.insert(2);<br/></span><span class="s1">   a.insert(3);<br/></span><span class="s1">   a.insert(4);<br/></span><span class="s1">   let b: HashSet&lt;u64&gt; = a.iter().cloned().map(|x| x/2).collect();<br/></span><span class="s1">   println!("{:?}", a);<br/></span><span class="s1">   println!("{:?}", b);<br/></span><span class="s1">}</span></pre>
<p>We see here that the resulting set is smaller than the original set due to collisions. This mapping still satisfies the properties of a functor. The defining properties of a functor are as follows:</p>
<ul>
<li>A collection of objects, <kbd>C</kbd></li>
<li>A mapping function that will transform objects in <kbd>C</kbd> into objects in <kbd>D</kbd></li>
</ul>
<p>The preceding <kbd>Set</kbd> map satisfies both the first and second property, and is therefore a proper functor. It also demonstrates how data can be transformed into a differently shaped structure through a functor. Using a little imagination, we may also consider the case where each mapped value may produce multiple outputs:</p>
<pre style="padding-left: 30px">fn main() {<br/><span class="s1">   let sentences = vec!["this is a sentence","paragraphs have many sentences"];<br/></span><span class="s1">   let words:Vec&lt;&amp;str&gt; = sentences.iter().flat_map(|&amp;x| x.split(" ")).collect();<br/></span><span class="s1">   println!("{:?}", sentences);<br/></span><span class="s1">   println!("{:?}", words);<br/></span><span class="s1">}</span></pre>
<p>Technically speaking, this last case is not a normal functor, but rather a contravariant functor. All functors are covariant. The distinction between covariance and contravariance is not important for our purposes, so we will leave that topic to only the most curious readers.</p>
<p>As a final definition by example, we should note that the input and output of a functor map need not be of the same type. For example, we can map from a vector to a <kbd>HashSet</kbd>:</p>
<pre class="p1"><span class="s1">use std::collections::{HashSet};<br/><br/></span><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let v: Vec&lt;u64&gt; = vec![1, 2, 3];<br/></span><span class="s1">   let s: HashSet&lt;u64&gt; = v.iter().cloned().map(|x| x/2).collect();<br/></span><span class="s1">   println!("{:?}", v);<br/></span><span class="s1">   println!("{:?}", s);<br/></span><span class="s1">}</span></pre>
<p>To give a non-trivial example of how the functor pattern could be used, let's look at webcams and AI. Modern AI facial recognition software is capable of identifying human faces in pictures and even visible emotional states. Let's imagine an app that connects to a webcam and processes the input with a filter. Here are some type definitions for the program:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct WebCamera;<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum VisibleEmotion {<br/></span><span class="s1">   Anger,<br/></span><span class="s1">   Contempt,<br/></span><span class="s1">   Disgust,<br/></span><span class="s1">   Fear,<br/></span><span class="s1">   Happiness,<br/></span><span class="s1">   Neutral,<br/></span><span class="s1">   Sadness,<br/></span><span class="s1">   Surprise<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug,Clone)]<br/></span><span class="s1">struct BoundingBox {<br/></span><span class="s1">   top: u64,<br/></span><span class="s1">   left: u64,<br/></span><span class="s1">   height: u64,<br/></span><span class="s1">   width: u64<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum CameraFilters {<br/></span><span class="s1">   Sparkles,<br/></span><span class="s1">   Rain,<br/></span><span class="s1">   Fire,<br/></span><span class="s1">   Disco<br/></span><span class="s1">}<br/><br/></span></pre>
<p>On the <kbd>WebCamera</kbd> type, we will implement two functors. One functor, <kbd>map_emotion</kbd>, will map emotions to other emotions. Maybe this could be used to add emojis to the text chat. The second contravariant functor, <kbd>flatmap_emotion</kbd>, maps emotions to zero, or more filters. These are animations or effects that can be applied back onto the web camera field of view:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl WebCamera {<br/></span><span class="s1">   fn map_emotion&lt;T,F&gt;(&amp;self, translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/></span><span class="s1">   where F: Fn(VisibleEmotion) -&gt; T {<br/></span><span class="s1">      //Simulate emotion extracted from WebCamera<br/></span><span class="s1">      vec![<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/></span><span class="s1">         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/></span><span class="s1">         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/></span><span class="s1">      ].into_iter().map(|(bb,emt)| {<br/></span><span class="s1">         (bb, translate(emt))<br/></span><span class="s1">      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/></span><span class="s1">   }<br/></span><span class="s1">   fn flatmap_emotion&lt;T,F,U:IntoIterator&lt;Item=T&gt;&gt;(&amp;self, mut translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/></span><span class="s1">   where F: FnMut(VisibleEmotion) -&gt; U {<br/></span><span class="s1">      //Simulate emotion extracted from WebCamera<br/></span><span class="s1">      vec![<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/></span><span class="s1">         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/></span><span class="s1">         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/></span><span class="s1">      ].into_iter().flat_map(|(bb,emt)| {<br/></span><span class="s1">         translate(emt).into_iter().map(move |t| (bb.clone(), t))<br/></span><span class="s1">      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/></span></pre>
<p>To use the functors, the programmer supplies which emotions map to which filters. The complex AI and effects can be easily modified due to the encapsulation provided by the functor pattern:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() {<br/></span><span class="s1">   let camera = WebCamera;<br/></span><span class="s1">   let emotes: Vec&lt;(BoundingBox,VisibleEmotion)&gt; = camera.map_emotion(|emt| {<br/></span><span class="s1">      match emt {<br/></span><span class="s1">         VisibleEmotion::Anger |<br/></span><span class="s1">         VisibleEmotion::Contempt |<br/></span><span class="s1">         VisibleEmotion::Disgust |<br/></span><span class="s1">         VisibleEmotion::Fear |<br/></span><span class="s1">         VisibleEmotion::Sadness =&gt; VisibleEmotion::Happiness,<br/></span><span class="s1">         VisibleEmotion::Neutral |<br/></span><span class="s1">         VisibleEmotion::Happiness |<br/></span><span class="s1">         VisibleEmotion::Surprise =&gt; VisibleEmotion::Sadness<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   let filters: Vec&lt;(BoundingBox,CameraFilters)&gt; = camera.flatmap_emotion(|emt| {<br/></span><span class="s1">      match emt {<br/></span><span class="s1">         VisibleEmotion::Anger |<br/></span><span class="s1">         VisibleEmotion::Contempt |<br/></span><span class="s1">         VisibleEmotion::Disgust |<br/></span><span class="s1">         VisibleEmotion::Fear |<br/></span><span class="s1">         VisibleEmotion::Sadness =&gt; vec![CameraFilters::Sparkles, CameraFilters::Rain],<br/></span><span class="s1">         VisibleEmotion::Neutral |<br/></span><span class="s1">         VisibleEmotion::Happiness |<br/></span><span class="s1">         VisibleEmotion::Surprise =&gt; vec![CameraFilters::Disco]<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   println!("{:?}",emotes);<br/></span><span class="s1">   println!("{:?}",filters);<br/>}</span></pre>


            </article>

            
        </section>
    </body>

</html>