<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Using functional design for concurrency</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Using functional design for concurrency</h1>
                </header>
            
            <article>
                
<p>Concurrency forces the programmer to be more careful about information sharing. This difficulty coincidentally encourages good functional programming practices, such as immutable data and pure functions; when computation is not context-sensitive, it tends to also be thread-safe.</p>
<p>Functional programming sounds great for concurrency, but are there downsides?</p>
<p>In one example of good intentions with bad effects, during development of a functional language called <strong>Haskell</strong>, the development team (<a href="https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell">https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell</a>) wanted to make programs run faster using concurrency. Due to a unique trait of the Haskell language, it was possible to run all expressions and sub-expressions in new threads. The development team thought this sounded great and tested it out.</p>
<p>The result was that more time was spent spawning new threads than doing any computation. The idea still had merit, but it turned out that implementing concurrency automatically would be difficult. There are many trade-offs in concurrent programming. Letting the programmer make decisions regarding these trade-offs is the current state-of-the-art.</p>
<p>So, from functional programming, what patterns have proven useful?</p>
<p>There are many patterns for concurrent programming, but here we will introduce a few primitives:</p>
<ul>
<li><strong>Actors</strong>: Threads and patterns of behavior</li>
<li><strong>Supervisors</strong>: Monitor and manage actors</li>
<li><strong>Routers</strong>: Send messages between actors</li>
<li><strong>Monads</strong>: Composable units of behavior</li>
</ul>
<p>First, let's look at actors in the following code:</p>
<pre class="p1" style="padding-left: 30px">use std::thread;<span class="s1"><br/></span><span class="s1">use std::sync::mpsc::{channel};<br/></span><span class="s1">use std::time;<br/><br/></span><span class="s1">fn main() {<br/></span><span class="s1">   let (pinginsend,pinginrecv) = channel();<br/></span><span class="s1">   let (pingoutsend,pingoutrecv) = channel();<br/></span><span class="s1">   let mut ping = 1;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let n = pinginrecv.recv().unwrap();<br/></span><span class="s1">         ping += n;<br/></span><span class="s1">         println!("ping {}", ping);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pingoutsend.send(ping).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   let (ponginsend,ponginrecv) = channel();<br/></span><span class="s1">   let (pongoutsend,pongoutrecv) = channel();<br/></span><span class="s1">   let mut pong = 2;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let n = ponginrecv.recv().unwrap();<br/></span><span class="s1">         pong += n;<br/></span><span class="s1">         println!("pong {}", pong);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pongoutsend.send(pong).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   let mut d = 3;<br/></span><span class="s1">   loop {<br/></span><span class="s1">      pinginsend.send(d).unwrap();<br/></span><span class="s1">      d = pingoutrecv.recv().unwrap();<br/></span><span class="s1">      ponginsend.send(d).unwrap();<br/></span><span class="s1">      d = pongoutrecv.recv().unwrap();<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Here we have two threads sending messages back and forth. Is this really much different than any of the previous examples?</p>
<p>There is a fairly common saying in functional programming that "<em>a closure is a poor man's object, and an object is a</em> <em>poor man's closure</em>".</p>
<p>According to object-oriented programming, objects have a type, fields, and methods. The closures we define hold their own mutable state, like fields of on an object. The ping and pong closures have slightly different types. The behavior inside the closure could be thought of as a single nameless method on the closure object. There are similarities here between object and closure.</p>
<p>However, it would be much nicer to use a normal object. The problem with attempting this is that the thread boundary gets in the way. Threads do not expose methods, only message passing. As a compromise, we could wrap the message passing into the form of methods. This would hide all of the channel management and would make programming with concurrent objects much nicer. We call this pattern the actor model.</p>
<p>An actor is very similar to an OOP object with the additional property that it lives in its own thread. Messages are sent to the actor, the actor processes the messages, and maybe sends out messages of its own. The actor model is like a busy city of people living and working doing different jobs but interacting and exchanging with one another according to their own schedules.</p>
<p>There are crates that attempt to provide elegant concurrent actor behavior, but we won't endorse any specifically. For the time being, please just squint your eyes and continue to pretend that closures are similar to objects.</p>
<p>In the next example, let's wrap these actors into functions so that they can be created more easily:</p>
<pre class="p1" style="padding-left: 30px">use std::thread;<span class="s1"><br/></span><span class="s1">use std::sync::mpsc::{channel,Sender,Receiver};<br/></span><span class="s1">use std::time;<br/></span><span class="s1">extern crate rand;<br/><br/></span><span class="s1">fn new_ping() -&gt; (Sender&lt;u64&gt;, Receiver&lt;u64&gt;) {<br/></span><span class="s1">   let (pinginsend,pinginrecv) = channel();<br/></span><span class="s1">   let (pingoutsend,pingoutrecv) = channel();<br/></span><span class="s1">   let mut ping = 1;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let n = pinginrecv.recv().unwrap();<br/></span><span class="s1">         ping += n;<br/></span><span class="s1">         println!("ping {}", ping);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pingoutsend.send(ping).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/></span><span class="s1">   (pinginsend, pingoutrecv)<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn new_pong() -&gt; (Sender&lt;u64&gt;, Receiver&lt;u64&gt;) {<br/></span><span class="s1">   let (ponginsend,ponginrecv) = channel();<br/></span><span class="s1">   let (pongoutsend,pongoutrecv) = channel();<br/></span><span class="s1">   let mut pong = 2;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let n = ponginrecv.recv().unwrap();<br/></span><span class="s1">         pong += n;<br/></span><span class="s1">         println!("pong {}", pong);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pongoutsend.send(pong).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/></span><span class="s1">   (ponginsend, pongoutrecv)<br/></span><span class="s1">}</span></pre>
<p>To run the example, we will create three of each type of actor and store the channels in a vector, as shown in the following code:</p>
<pre style="padding-left: 30px">fn main() {<br/>   let pings = vec![new_ping(), new_ping(), new_ping()];<br/>   let pongs = vec![new_pong(), new_pong(), new_pong()];<br/>   loop {<br/>      let mut d = 3;<br/><br/>      let (ref pingin,ref pingout) = pings[(rand::random::&lt;u64&gt;() % 3) as usize];<br/>      pingin.send(d).unwrap();<br/>      d = pingout.recv().unwrap();<br/><br/>      let (ref pongin,ref pongout) = pongs[(rand::random::&lt;u64&gt;() % 3) as usize];<br/>      pongin.send(d).unwrap();<br/>      pongout.recv().unwrap();<br/>   }<br/>}</pre>
<p>Now, we have actors and a really basic supervisor for each actor group. The supervisor here is just a vector to keep track of communication channels for each actor. A good supervisor should periodically check the health of each actor, kill bad actors, and resupply the stock of good actors.</p>
<p>The last actor-based primitive that we will mention is routing. Routing is the method equivalent of object-oriented programming. OOP method calls were originally called <strong>message passing</strong>. The actor model is very object-oriented and accordingly we still call methods by actually passing messages around. We are still using the poor man's objects (closures), so our routing will probably look like a glorified <kbd>if</kbd> statement.</p>
<p>To start our actor router, we will define two data types—addresses and messages. Addresses should define all possible destinations and routing behaviors for messages. Messages should correspond to all possible method calls from all actors. Here is our extended ping pong application:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::thread;<br/></span><span class="s1">use std::sync::mpsc::{channel,Sender,Receiver};<br/></span><span class="s1">use std::time;<br/></span><span class="s1">extern crate rand;<br/><br/></span><span class="s1">enum Address {<br/></span><span class="s1">   Ping,<br/></span><span class="s1">   Pong<br/></span><span class="s1">}<br/><br/></span><span class="s1">enum Message {<br/></span><span class="s1">   PingPlus(u64),<br/></span><span class="s1">   PongPlus(u64),<br/></span><span class="s1">}</span></pre>
<p>Then we define our actors. They now need to match against the new <kbd>Message</kbd> type, and outgoing messages should have an <kbd>Address</kbd> in addition to a <kbd>Message</kbd>. Despite the changes, the code remains very similar to before:</p>
<pre class="p1">fn new_ping() -&gt; (Sender&lt;<span class="s1">Message&gt;, Receiver&lt;(Address,Message)&gt;) {<br/></span><span class="s1">   let (pinginsend,pinginrecv) = channel();<br/></span><span class="s1">   let (pingoutsend,pingoutrecv) = channel();<br/></span><span class="s1">   let mut ping = 1;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let msg = pinginrecv.recv().unwrap();<br/></span><span class="s1">         match msg {<br/></span><span class="s1">            Message::PingPlus(n) =&gt; { ping += n; },<br/></span><span class="s1">            _ =&gt; panic!("Unexpected message")<br/></span><span class="s1">         }<br/></span><span class="s1">         println!("ping {}", ping);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pingoutsend.send((<br/></span><span class="s1">            Address::Pong,<br/></span><span class="s1">            Message::PongPlus(ping)<br/></span><span class="s1">         )).unwrap();<br/></span><span class="s1">         pingoutsend.send((<br/></span><span class="s1">            Address::Pong,<br/></span><span class="s1">            Message::PongPlus(ping)<br/></span><span class="s1">         )).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/></span><span class="s1">   (pinginsend, pingoutrecv)<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn new_pong() -&gt; (Sender&lt;Message&gt;, Receiver&lt;(Address,Message)&gt;) {<br/></span><span class="s1">   let (ponginsend,ponginrecv) = channel();<br/></span><span class="s1">   let (pongoutsend,pongoutrecv) = channel();<br/></span><span class="s1">   let mut pong = 1;<br/></span><span class="s1">   thread::spawn(move || {<br/></span><span class="s1">      let t = time::Duration::from_millis(1000);<br/></span><span class="s1">      loop {<br/></span><span class="s1">         let msg = ponginrecv.recv().unwrap();<br/></span><span class="s1">         match msg {<br/></span><span class="s1">            Message::PongPlus(n) =&gt; { pong += n; },<br/></span><span class="s1">            _ =&gt; panic!("Unexpected message")<br/></span><span class="s1">         }<br/></span><span class="s1">         println!("pong {}", pong);<br/></span><span class="s1">         thread::sleep(t);<br/></span><span class="s1">         pongoutsend.send((<br/></span><span class="s1">            Address::Ping,<br/></span><span class="s1">            Message::PingPlus(pong)<br/></span><span class="s1">         )).unwrap();<br/></span><span class="s1">         pongoutsend.send((<br/></span><span class="s1">            Address::Ping,<br/></span><span class="s1">            Message::PingPlus(pong)<br/></span><span class="s1">         )).unwrap();<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/></span><span class="s1">   (ponginsend, pongoutrecv)<br/></span><span class="s1">}</span></pre>
<p>Each ping pong process loops to consume one message and send two more across. The last component for the program is initialization and routing:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<span class="s1"><br/></span><span class="s1">   let pings = vec![new_ping(), new_ping(), new_ping()];<br/></span><span class="s1">   let pongs = vec![new_pong(), new_pong(), new_pong()];<br/><br/></span><span class="s1">   //Start the action<br/></span><span class="s1">   pings[0].0.send(Message::PingPlus(1)).unwrap();<br/><br/></span><span class="s1">   //This thread will be the router<br/>   //This is a busy wait and otherwise bad code<br/>   //select! would be much better, but it is still experimental<br/>   //https://doc.rust-lang.org/std/macro.select.html<br/></span><span class="s1">   let t = time::Duration::from_millis(10);<br/></span><span class="s1">   loop {<br/></span><span class="s1">      let mut mail = Vec::new();<br/></span><span class="s1"><br/>      for (_,r) in pings.iter() {<br/></span><span class="s1">         for (addr,msg) in r.try_iter() {<br/></span><span class="s1">            mail.push((addr,msg));<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">      for (_,r) in pongs.iter() {<br/></span><span class="s1">         for (addr,msg) in r.try_iter() {<br/></span><span class="s1">            mail.push((addr,msg));<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/><br/></span>      for (addr,msg) in mail.into_iter() {<br/><span class="s1">         match addr {<br/></span><span class="s1">            Address::Ping =&gt; {<br/></span><span class="s1">               let (ref s,_) = pings[(rand::random::&lt;u32&gt;() as usize) % pings.len()];<br/></span><span class="s1">               s.send(msg).unwrap();<br/></span><span class="s1">            },<br/></span><span class="s1">            Address::Pong =&gt; {<br/></span><span class="s1">               let (ref s,_) = pongs[(rand::random::&lt;u32&gt;() as usize) % pongs.len()];<br/></span><span class="s1">               s.send(msg).unwrap();<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">      thread::sleep(t);<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>After initializing the different actors, the main thread starts acting as the router. The <span>router is a single thread with the sole responsibility of finding destinations, then moving, copying, cloning, and otherwise distributing messages to the recipient threads. This is not a complex solution, but it is effective, and uses only the typesafe, thread-safe, platform-independent primitives that we have introduced so far.</span></p>
<p>In a more complex example, the routing <kbd>Address</kbd> will typically have the following:</p>
<ul>
<li>An actor role</li>
<li>A method name</li>
<li>Argument type signatures</li>
</ul>
<p>The message would then be the arguments according to the preceding type signature. Sending a message from an actor is as simple as sending your <kbd>(Address,Message)</kbd> to the router. The router at this time should be regularly checking each channel for new routing requests. When it sees the new message, it will pick an actor that satisfies the <kbd>Address</kbd> condition and send the message to that actor's inbox.</p>
<p>Watching the output, each ping pong action doubles the number of messages received. If each thread didn't do so much sleeping, then the program could get out of hand quickly. Messaging noise is one risk of overusing the actor model.</p>


            </article>

            
        </section>
    </body>

</html>