<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Using the monad pattern</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Using the monad pattern</h1>
                </header>
            
            <article>
                
<p>A monad defines <kbd>return</kbd> and <kbd>bind</kbd> operations for a type. The <kbd>return</kbd> operation is like a constructor to make the monad. The <kbd>bind</kbd> operation incorporates new information and returns a new monad. There are also several laws that monads should obey. Rather than quote the laws, we'll just say that monads should behave well when daisy chained like the following:</p>
<pre style="padding-left: 30px">MyMonad::return(value)  //We start with a new MyMonad&lt;A&gt;<br/>        .bind(|x| x+x)  //We take a step into MyMonad&lt;B&gt;<br/>        .bind(|y| y*y); //Similarly we get to MyMonad&lt;C&gt;</pre>
<p>In Rust, there are several semi-monads that appear in standard libraries:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   let v1 = Some(2).and_then(|x| Some(x+x)).and_then(|y| Some(y*y));<br/></span><span class="s1">   println!("{:?}", v1);<br/><br/></span><span class="s1">   let v2 = None.or_else(|| None).or_else(|| Some(222));<br/></span><span class="s1">   println!("{:?}", v2);<br/></span><span class="s1">}</span></pre>
<p>In this example, the normal <kbd>Option</kbd> constructors, <kbd>Some</kbd> or <kbd>None</kbd>, take the place of the monadic naming convention, <kbd>return</kbd>. There are two semi-monads implemented here, one associated with <kbd>and_then</kbd>, and the other with <kbd>or_else</kbd>. Both of these correspond to the monadic <kbd>bind</kbd> naming convention for the operator responsible for incorporating new information into a new monad return value.</p>
<p>Monadic <kbd>bind</kbd> operations are also polymorphic, meaning they should permit returning monads of different types from the current monad. According to this rule, <kbd>or_else</kbd> is not technically a monad; hence it is a semi-monad:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let v3 = Some(2).and_then(|x| Some("abc"));<br/></span><span class="s1">   println!("{:?}", v3);<br/><br/></span><span class="s1">   // or_else is not quite a monad<br/></span><span class="s1">   // does not permit polymorphic bind<span class="Apple-converted-space"><br/></span></span><span class="s1">   //let v4 = Some(2).or_else(|| Some("abc"));<br/></span><span class="s1">   //println!("{:?}", v4);<br/></span><span class="s1">}</span></pre>
<p>Monads were originally developed to express side-effects in purely functional languages. Isn't that a contradiction—pure with side-effects?</p>
<p>The answer is <em>no</em> if the effects are passed as input and output through pure functions. However, for this to work, every function would need to declare every state variable and pass it along, which could become a huge list of parameters. This is where monads come in. A monad can hide state inside itself, which becomes essentially a larger, more complex function than what the programmer interacts with.</p>
<p>One concrete example of side-effect hiding is the concept of a universal logger. The monadic <kbd>return</kbd> and <kbd>bind</kbd> can be used to wrap state and computation inside of a monad that will log all intermediate results. Here is the logger monad:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::fmt::{Debug};<br/><br/></span><span class="s1">struct LogMonad&lt;T&gt;(T);<br/></span><span class="s1">impl&lt;T&gt; LogMonad&lt;T&gt; {<br/></span><span class="s1">   fn _return(t: T) -&gt; LogMonad&lt;T&gt;<br/></span><span class="s1">   where T: Debug {<br/></span><span class="s1">      println!("{:?}", t);<br/></span><span class="s1">      LogMonad(t)<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;R,F&gt;(&amp;self, f: F) -&gt; LogMonad&lt;R&gt;<br/></span><span class="s1">   wher</span>e F: FnOnce(<span class="s1">&amp;T) -&gt; R,<br/></span><span class="s1">   R: Debug {<br/></span><span class="s1">      let r = f(&amp;self.0);<br/></span><span class="s1">      println!("{:?}", r);<br/></span><span class="s1">      LogMonad(r)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   LogMonad::_return(4)<br/></span><span class="s1">            .bind(|x| x+x)<br/></span><span class="s1">            .bind(|y| y*y)<br/></span><span class="s1">            .bind(|z| format!("{}{}{}", z, z, z));<br/></span><span class="s1">}</span></pre>
<p>As long as each result implements the <kbd>Debug</kbd> trait, it can be automatically logged with this pattern.</p>
<p>The monad pattern is also very useful for chaining together code that can't be written in a normal code block. For example, code blocks are always evaluated eagerly. If you want to define code that will be evaluated later or in pieces, the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe code or data that is not evaluated until it is referenced. This is contrary to the typical eager evaluation of Rust code that will execute immediately regardless of context. Here is the lazy monad pattern:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct LazyMonad&lt;A,B&gt;(Box&lt;Fn(A) -&gt; B&gt;);<br/><br/></span><span class="s1">impl&lt;A: 'static,B: 'static&gt; LazyMonad&lt;A,B&gt; {<br/></span><span class="s1">   fn _return(u: A) -&gt; LazyMonad&lt;B,B&gt; {<br/></span><span class="s1">      LazyMonad(Box::new(move |b: B| b))<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;C,G: 'static&gt;(self, g: G) -&gt; LazyMonad&lt;A,C&gt;<br/></span><span class="s1">   where G: Fn(B) -&gt; C {<br/></span><span class="s1">      LazyMonad(Box::new(move |a: A| g(self.0(a))))<br/></span><span class="s1">   }<br/></span><span class="s1">   fn apply(self, a: A) -&gt; B {<br/></span><span class="s1">      self.0(a)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let notyet = LazyMonad::_return(())   //we create LazyMonad&lt;()&gt;</span><span class="s1"><br/></span><span class="s1">                          .bind(|x| x+2) //and now a LazyMonad&lt;A&gt;<br/></span><span class="s1">                          .bind(|y| y*3) //and now a LazyMonad&lt;B&gt;<br/></span><span class="s1">                          .bind(|z| format!("{}{}", z, z));<br/><br/></span><span class="s1">   let nowdoit = notyet.apply(222); //The above code now run<br/></span><span class="s1">   println!("nowdoit {}", nowdoit);<br/></span>}</pre>
<p>This block defines statements that will be evaluated one at a time after a value is supplied, but not before. This may seem a bit trivial since we can do the same with a simple closure and code block; however, to make this pattern stick, let's consider a more complex case—an asynchronous web server.</p>
<p>A web server will typically receive a full HTTP request before processing it. Choosing what to do with a request is sometimes called <strong>routing</strong>. Then requests are sent to a request handler. In the following code, we define a server that helps us wrap routes and handlers into a single web server object. Here are the type and method definitions:</p>
<pre class="p1"><span class="s1">use std::io::prelude::*;<br/></span><span class="s1">use std::net::TcpListener;<br/></span><span class="s1">use std::net::TcpStream;<br/><br/></span><span class="s1">struct ServerMonad&lt;St&gt; {<br/></span><span class="s1">   state: St,<br/></span><span class="s1">   handlers: Vec&lt;Box&lt;Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt;&gt;&gt;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;St: Clone&gt; ServerMonad&lt;St&gt; {<br/></span><span class="s1">   fn _return(st: St) -&gt; ServerMonad&lt;St&gt; {<br/></span><span class="s1">      ServerMonad {<br/></span><span class="s1">         state: st,<br/></span><span class="s1">         handlers: Vec::new()<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn listen(&amp;mut self, address: &amp;str) {<br/></span><span class="s1">      let listener = TcpListener::bind(address).unwrap();<br/></span><span class="s1">      for stream in listener.incoming() {<br/></span><span class="s1">         let mut st = self.state.clone();<br/></span><span class="s1">         let mut buffer = [0; 2048];<br/></span><span class="s1">         let mut tcp = stream.unwrap();<br/></span><span class="s1">         tcp.read(&amp;mut buffer);<br/></span><span class="s1">         let buffer = String::from_utf8_lossy(&amp;buffer).into_owned();<br/></span><span class="s1">         for h in self.handlers.iter() {<br/></span><span class="s1">            if let Some(response) = h(&amp;mut st,&amp;buffer) {<br/></span><span class="s1">               tcp.write(response.as_bytes());<br/></span><span class="s1">               break<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind_handler&lt;F&gt;(mut self, f: F) -&gt; Self<br/></span><span class="s1">      where F: 'static + Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt; {<br/></span><span class="s1">      self.handlers.push(Box::new(f));<br/></span><span class="s1">      self<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>This type defines <kbd>return</kbd> and <kbd>bind</kbd> like operations. However, the <kbd>bind</kbd> function is not polymorphic and the operation is not a pure function. Without these compromises, we would need to fight against the Rust type and ownership system; the preceding example is not written monadically due to complications when trying to box and copy closures. This is an expected trade-off and the semi-monad pattern should not be discouraged when appropriate.</p>
<p>To define our web server responses, we can attach handlers like in the following code:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/><span class="s1">   ServerMonad::_return(())<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%2 == 0 { Some("divisible by 2".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%3 == 0 { Some("divisible by 3".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%5 == 0 { Some("divisible by 5".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%7 == 0 { Some("divisible by 7".to_string()) } else { None })<br/></span><span class="s1">               .listen("127.0.0.1:8888");<br/></span>}</pre>
<p>If you run this program and send messages to localhost <kbd>8888</kbd>, then you may get a response if the message length is divisible by <kbd>2</kbd>, <kbd>3</kbd>, <kbd>5</kbd>, or <kbd>7</kbd>.</p>


            </article>

            
        </section>
    </body>

</html>