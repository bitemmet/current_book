<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Mutability, Ownership, and Pure Functions</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Mutability, Ownership, and Pure Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Rust has introduced some new concepts of its own with respect to object ownership. These safeguards protect the developer from certain classes of errors, such as double free memory or hanging pointers, but also create constraints that can feel unmerited at times. Functional programming may help ease some of this conflict by encouraging the use of immutable data and pure functions.</p>
<p>In this chapter, we will look at a case of ownership gone wrong. You will inherit code that has been abandoned as being too difficult to work with. Your job in this chapter will be to address the problems that the previous team were unable to overcome. To achieve this, you will need to use much of what you have learned so far, along with a gained understanding of the specific behaviors and constraints of ownership in Rust.</p>
<p>Learning outcomes:</p>
<ul>
<li>Recognizing anti-patterns of complex ownership</li>
<li>Learning specific rules of complex ownership</li>
<li>Using immutable data to prevent anti-patterns of ownership</li>
<li>Using pure functions to prevent anti-patterns of ownership</li>
</ul>


            </article>

            
        </section>
    </body>

</html>