<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Code Organization and Application Architecture</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Code Organization and Application Architecture</h1>
                </header>
            
            <article>
                
<p>Previously, we outlined some basic concepts of project planning and code architecture. The strategy we recommended specifically called for gathering and listing requirements before adapting them into pseudocode, stub code, and eventually a completed project. This process is still very applicable to larger projects, but we have not covered the aspect of file and module organization. How should code be grouped into files and modules?</p>
<p>To answer this question, we recommend something called <strong>the workshop model</strong>. Imagine a physical workshop with pegboards, shelves, jars, toolboxes, and larger equipment on the floor. When speaking about code architecture, experts often talk about different organizational strategies. It is possible to group code by type, by purpose, by project layer, or by convenience. There are infinite possible strategies, and these are just four common ones. None of these are wrong, though we recommend against choosing any one specifically. Our reason is simpleâ€”choose all of them. Nuts and bolts can be organized into jars (by type). Hand tools can be placed in a toolbox (by purpose). Large tools can be placed on the floor (by project layer). Common tools can be hung on a pegboard (by convenience). None of these strategies are invalid, and all of them can be used in the same workshop (project).</p>
<p>In this chapter, we will reorganize the project as it grows. We will combine the principles of planning and architecture that we previously introduced with new concepts of code organization to develop a large software project that is navigable and maintainable.</p>
<p>The learning outcomes of this chapter are as follows:</p>
<ul>
<li>Recognizing and applying by type organization</li>
<li>Recognizing and applying by purpose organization</li>
<li>Recognizing and applying by layer organization</li>
<li>Recognizing and applying by convenience organization</li>
<li>Minimizing code waste during project reorganization</li>
</ul>


            </article>

            
        </section>
    </body>

</html>