<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Parser combinators</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Parser combinators</h1>
                </header>
            
            <article>
                
<p>Another major application of combinators is parser combinators. A parser combinator makes use of both the monad and combinator patterns. The monadic <kbd>bind</kbd> functions are used to bind data from parsers that are later returned as a parse result. The combinators join parsers into a sequence, failover, or other patterns.</p>
<p>The <kbd>chomp</kbd> parser combinator library is a good implementation of this concept. Also, the library provides a nice <kbd>parse!</kbd> macro that makes the combinator logic much easier to read. Here is an example:</p>
<pre class="p1"><span class="s1">#[macro_use]<br/></span><span class="s1">extern crate chomp;<br/></span><span class="s1">use chomp::prelude::*;<br/><br/></span><span class="s1">#[derive(Debug, Eq, PartialEq)]<br/></span><span class="s1">struct Name&lt;B: Buffer&gt; {<br/></span><span class="s1">   first: B,<br/></span><span class="s1">   last:<span class="Apple-converted-space">  </span>B,<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn name&lt;I: U8Input&gt;(i: I) -&gt; SimpleResult&lt;I, Name&lt;I::Buffer&gt;&gt; {<br/></span><span class="s1">   parse!{i;<br/></span><span class="s1">      let first = take_while1(|c| c != b' ');<br/></span><span class="s1">      token(b' ');<span class="Apple-converted-space">  </span>// skipping this char<br/></span><span class="s1">      let last<span class="Apple-converted-space">  </span>= take_while1(|c| c != b'\n');<br/><br/></span><span class="s1">      ret Name{<br/></span><span class="s1">         first: first,<br/></span><span class="s1">         last:<span class="Apple-converted-space">  </span>last,<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span><span class="s1"><br/><br/></span>fn main() {<br/><span class="s1">   let parse_result = parse_only(name, "Martin Wernstål\n".as_bytes()).unwrap();<br/></span><span class="s1">   println!("first:{} last:{}",<br/></span></pre>
<pre class="p1"><span class="s1">      String::from_utf8_lossy(parse_result.first),<br/></span><span class="s1">      String::from_utf8_lossy(parse_result.last));<br/></span>}</pre>
<p>Here, the example defines a grammar for a first name, last name parser. In the name function, the parser is defined with a macro. The inside of the macro looks almost like a normal code, like the <kbd>let</kbd> statements, function calls, and closure definitions. However, the generated code is actually a mix of monads and combinators.</p>
<p>Each <kbd>let</kbd> binding corresponds to a combinator. Each semicolon corresponds to a combinator. The functions <kbd>take_while1</kbd> and <kbd>token</kbd> are both combinators that introduce parser monads. Then, when the macro ends, we are left with an expression that processes the input to parse a result.</p>
<p>This <kbd>chomp</kbd> parser combinator library is fully featured and may be hard to understand if you just casually examined the source code. To see what is happening here, let's create our own parser combinators. First, let's define the parser state:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::rc::Rc;<br/><br/></span><span class="s1">#[derive(Clone)]<br/></span><span class="s1">struct ParseState&lt;A: Clone&gt; {<br/></span><span class="s1">   buffer: Rc&lt;Vec&lt;char&gt;&gt;,<br/></span><span class="s1">   index: usize,<br/></span><span class="s1">   a: A<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;A: Clone&gt; ParseState&lt;A&gt; {<br/></span><span class="s1">   fn new(a: A, buffer: String) -&gt; ParseState&lt;A&gt; {<br/></span><span class="s1">      let buffer: Vec&lt;char&gt; = buffer.chars().collect();<br/></span><span class="s1">      ParseState {<br/></span><span class="s1">         buffer: Rc::new(buffer),<br/></span><span class="s1">         index: 0,<br/></span><span class="s1">         a: a<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn next(&amp;self) -&gt; (ParseState&lt;A&gt;,Option&lt;char&gt;) {</span><span class="s1"><br/></span><span class="s1">      if self.index &lt; self.buffer.len() {<br/></span><span class="s1">         let new_char = self.buffer[self.index];<br/></span><span class="s1">         let new_index = self.index + 1;<br/></span><span class="s1">         (ParseState {<br/></span><span class="s1">            buffer: Arc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: new_index,<br/></span><span class="s1">            a: self.a.clone()<br/></span><span class="s1">         }, Some(new_char))<br/></span><span class="s1">      } else {<br/></span><span class="s1">         (ParseState {<br/></span><span class="s1">            buffer: Rc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: self.index,<br/></span><span class="s1">            a: self.a.clone()<br/></span><span class="s1">         },None)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">struct ParseRCon&lt;A,B&gt;(A,Result&lt;Option&lt;B&gt;,String&gt;);<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum ParseOutput&lt;A&gt; {<br/></span><span class="s1">   Success(A),<br/></span><span class="s1">   Failure(String)<br/></span><span class="s1">}</span></pre>
<p>Here we define <kbd>ParseState</kbd>, <kbd>ParseRCon</kbd>, and <kbd>ParseResult</kbd>. The parse state keeps track of what character index the parser is at. The parse state often also records information, such as the line and column number.</p>
<p>The <kbd>ParseRCon</kbd> structure encapsulates state along with an optional value wrapped in a result. If an unrecoverable error happens while parsing, the result will become <kbd>Err</kbd>. If a recoverable error happens while parsing, the option will be <kbd>None</kbd>. Otherwise, the parsers should work mostly as if they expect to always have the optional value.</p>
<p>The <kbd>ParseResult</kbd> type is returned at the very end of a parse execution to provide a successful result or error message.</p>
<p>The parser monads and combinators are defined ad hoc with different functions. To create a parser, the simplest options would be <kbd>parse_mzero</kbd> and <kbd>parse_return</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse&lt;St: Clone,A,P&gt;(p: &amp;P, st: &amp;ParseState&lt;St&gt;) -&gt; ParseOutput&lt;A&gt;<br/></span><span class="s1">   where P: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   match p(st.clone()) {<br/></span><span class="s1">      ParseRCon(_,Ok(Some(a))) =&gt; ParseOutput::Success(a),<br/></span><span class="s1">      ParseRCon(_,Ok(None)) =&gt; ParseOutput::Failure("expected input".to_string()),<br/></span><span class="s1">      ParseRCon(_,Err(err)) =&gt; ParseOutput::Failure(err)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_mzero&lt;St: Clone,A&gt;(st: ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   ParseRCon(st,Err("mzero failed".to_string()))<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_return&lt;St: Clone,A: Clone&gt;(a: A) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;) {<br/></span><span class="s1">   move |st| { ParseRCon(st,Ok(Some(a.clone()))) }<br/></span><span class="s1">}<br/><br/>fn main() {<br/></span><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/><br/></span><span class="s1">   let p1 = parse_mzero::&lt;(),()&gt;;<br/></span><span class="s1">   println!("p1 input1: {:?}", parse(&amp;p1,&amp;input1));<br/></span><span class="s1">   println!("p1 input2: {:?}", parse(&amp;p1,&amp;input2));<br/><br/></span><span class="s1">   let p2 = parse_return(123);<br/></span><span class="s1">   println!("p2 input1: {:?}", parse(&amp;p2,&amp;input1));<br/></span><span class="s1">   println!("p2 input2: {:?}", parse(&amp;p2,&amp;input2));<br/>}</span></pre>
<p>The <kbd>parse_mzero</kbd> monad always fails and returns a simple message. The <kbd>parse_return</kbd> always succeeds and returns a given value.</p>
<p>To make things more interesting, let's actually look at a parser that consumes input. We create the following two functions—<kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd>. <kbd>parse_token</kbd> will always consume one token and return its value unless there is no more input. <kbd>parse_satisfy</kbd> will consume a token if the token satisfies some condition. Here are the definitions:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse_token&lt;St: Clone,A,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;)<br/></span><span class="s1">   where T: 'static + Fn(char) -&gt; Option&lt;A&gt; {<br/></span><span class="s1">   move |st: ParseState&lt;St&gt;| {<br/></span><span class="s1">      let (next_state,next_char) = st.clone().next();<br/></span><span class="s1">      match next_char {<br/></span><span class="s1">         Some(c) =&gt; ParseRCon(next_state,Ok(t(c))),<br/></span><span class="s1">         None =&gt; ParseRCon(st,Err("end of input".to_string()))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_satisfy&lt;St: Clone,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,char&gt;)<br/></span><span class="s1">   where T: 'static + Fn(char) -&gt; bool {<br/></span><span class="s1">   parse_token(move |c| if t(c) {Some(c)} else {None})<br/></span><span class="s1">}<br/><br/>fn main() {<br/></span><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/></span><span class="s1"><br/></span><span class="s1">   let p3 = parse_satisfy(|c| c=='1');<br/></span><span class="s1">   println!("p3 input1: {:?}", parse(&amp;p3,&amp;input1));<br/></span><span class="s1">   println!("p3 input2: {:?}", parse(&amp;p3,&amp;input2));<br/><br/></span><span class="s1">   let digit = parse_satisfy(|c| c.is_digit(10));<br/></span><span class="s1">   println!("digit input1: {:?}", parse(&amp;digit,&amp;input1));<br/></span><span class="s1">   println!("digit input2: {:?}", parse(&amp;digit,&amp;input2));<br/><br/></span><span class="s1">   let space = parse_satisfy(|c| c==' ');<br/></span><span class="s1">   println!("space input1: {:?}", parse(&amp;space,&amp;input1));<br/></span><span class="s1">   println!("space input2: {:?}", parse(&amp;space,&amp;input2));<br/><br/></span><span class="s1">   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/></span><span class="s1">   println!("operator input1: {:?}", parse(&amp;operator,&amp;input1));<br/></span><span class="s1">   println!("operator input2: {:?}", parse(&amp;operator,&amp;input2));</span><span class="s1"><br/>}</span></pre>
<p>The <kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd> look at one token. If the token satisfies the provided condition, it then returns the input token. Here, we create several conditions to correspond to single character matching, digits, spaces, or arithmetic operators.</p>
<p>These functions can be composed using high-level combinators to create complex grammar:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse_bind&lt;St: Clone,A,B,P1,P2,B1&gt;(p1: P1, b1: B1)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;,<br/></span><span class="s1">         B1: Fn(A) -&gt; P2 {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st) {<br/></span><span class="s1">         ParseRCon(nst,Ok(Some(a))) =&gt; b1(a)(nst),<br/></span><span class="s1">         ParseRCon(nst,Ok(None)) =&gt; ParseRCon(nst,Err("bind failed".to_string())),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_sequence&lt;St: Clone,A,B,P1,P2&gt;(p1: P1, p2: P2)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt; {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st) {<br/></span><span class="s1">         ParseRCon(nst,Ok(_)) =&gt; p2(nst),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_or&lt;St: Clone,A,P1,P2&gt;(p1: P1, p2: P2)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st.clone()) {<br/></span><span class="s1">         ParseRCon(nst,Ok(Some(a))) =&gt; ParseRCon(nst,Ok(Some(a))),<br/></span><span class="s1">         ParseRCon(_,Ok(None)) =&gt; p2(st),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/></span><br/><span class="s1">   let digit = parse_satisfy(|c| c.is_digit(10));<br/></span><span class="s1">   let space = parse_satisfy(|c| c==' ');<br/></span><span class="s1">   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/></span><span class="s1">   let ps1 = parse_sequence(digit,space);<br/></span><span class="s1">   let ps2 = parse_sequence(ps1,operator);<br/></span><span class="s1">   println!("digit,space,operator input1: {:?}", parse(&amp;ps2,&amp;input1));<br/></span><span class="s1">   println!("digit,space,operator input2: {:?}", parse(&amp;ps2,&amp;input2));<br/></span>}</pre>
<p>Here, we see how the monadic <kbd>parse_bind</kbd> or its derivative, <kbd>parse_sequence</kbd>, can be used to sequence two parsers together. We don't have an example here but the failover combinator is also defined in <kbd>parse_or</kbd>.</p>
<p>Using these primitives, we can create nice tools to help us generate complex parsers that expect, store, and manipulate data from token streams. Parse combinators are one of the more practical yet challenging applications of monads and combinators. The fact that these concepts are at all possible in Rust demonstrates how far the language has developed towards supporting functional concepts.</p>


            </article>

            
        </section>
    </body>

</html>