<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Investigating generalized algebraic datatypes</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Investigating generalized algebraic datatypes</h1>
                </header>
            
            <article>
                
<p>Sometimes, it is desirable to have the type system carry more information than normal. If we look at the process of compilation, types occupy a space between the program code and the program executable. The code can take the form of text files before compilation or an abstract syntax tree such as those manipulated by Rust macros. Program executables consist of the resulting combination of all Rust primitives like expressions, functions, datatypes, traits, and so on.</p>
<p>Right in the middle, it is possible to introduce a new concept called <strong>algebraic data types </strong>(<strong>ADTs</strong>). ADTs are technically an extension of Rust primitives, though it is important to note how much extra type information is used for ADTs. This technique involves preserving extra type information into the executable. Extra run time decision-making is a step towards dynamic typing and foregoes optimizations available to static compilation. The result is a somewhat less efficient programming primitive, but also a primitive that can describe concepts that are otherwise difficult to approach.</p>
<p>Let's look at one example—deferred computation. When we describe a relation of different values and expressions, we normally just write this code into the program directly. However, what would we do if we wanted to separate the code step from the execution step? To accomplish this, we start building something called a <strong>domain-specific language</strong>.</p>
<p>For a concrete example, consider that you are building a JIT (dynamically compiled) interpreter for JavaScript. The Mozilla project has several projects dedicated to JS engines built in Rust (<a href="https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/">https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/</a>). This is a real application for which Rust is well-suited. To use an ADT in a JIT compiled interpreter, we want two things:</p>
<ul>
<li>To evaluate ADT expressions directly within the interpreter</li>
<li>To compile ADT expressions if selected for compilation</li>
</ul>
<p>So, any part of our JavaScript expressions can either be interpreted or compiled at any time. If an expression is compiled, then we want all further evaluations to use the compiled version. The key to implementing this cleanly is to put some extra weight on the type system. These heavy type definitions are the essence of the ADT concept. Here is a definition of a very small subset of JavaScript using an ADT:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct JSJIT(u64);<br/><br/></span><span class="s1">enum JSJITorExpr {<br/></span><span class="s1">   Jit { label: Box&lt;JSJIT&gt; },<br/></span><span class="s1">   Expr { expr: Box&lt;JSExpr&gt; }<br/></span><span class="s1">}<br/><br/></span><span class="s1">enum JSExpr {<br/></span><span class="s1">   Integer { value: u64 },<br/></span><span class="s1">   String { value: String },<br/></span><span class="s1">   OperatorAdd { lexpr: Box&lt;JSJITorExpr&gt;, rexpr: Box&lt;JSJITorExpr&gt; },<br/></span><span class="s1">   OperatorMul { lexpr: Box&lt;JSJITorExpr&gt;, rexpr: Box&lt;JSJITorExpr&gt; }<br/></span><span class="s1">}</span></pre>
<p class="mce-root"><span>Here, we can see that each intermediate expression has enough information to be evaluated, but also has enough information to be compiled. We could have easily wrapped the <kbd>Add</kbd> or <kbd>Mul</kbd> operator into closures, but that would disallow JIT optimization. We need to maintain the full representation here in order to permit JIT compilation. Also, note the indirection between each point where the program decides whether to evaluate an expression or to call into compiled code.</span></p>
<p>The next step is to implement an evaluation program for each expression form. We could break this into traits, or define the evaluation as one larger function. To keep the functional style, we will define a single function. To evaluate an expression, we will use a pattern match on the <kbd>JSJITorExpr</kbd> expression. This JIT expression breaks down into either a code address which is run by calling the <kbd>jump</kbd> function or an expression which must be evaluated dynamically. This pattern gives us the best of both worlds, mixing compiled code and interpreted code together. The code is as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn jump(l: JSJIT) -&gt; JSJITorExpr<br/></span><span class="s1">{<br/></span><span class="s1">   //jump to compiled code<br/></span><span class="s1">   //this depends on implementation<br/></span><span class="s1">   //so we will just leave this as a stub<br/></span><span class="s1">   JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn eval(e: JSJITorExpr) -&gt; JSJITorExpr<br/></span><span class="s1">{<br/></span><span class="s1">   match e<br/></span><span class="s1">   {<br/></span><span class="s1">      JSJITorExpr::Jit { label: label } =&gt; jump(label),<br/></span><span class="s1">      JSJITorExpr::Expr { expr: expr } =&gt; {<br/></span><span class="s1">         let rawexpr = *expr;<br/></span><span class="s1">         match rawexpr<br/></span><span class="s1">         {<br/></span><span class="s1">            JSExpr::Integer {..} =&gt; JSJITorExpr::Expr { expr: Box::new(rawexpr) },<br/></span><span class="s1">            JSExpr::String {..} =&gt; JSJITorExpr::Expr { expr: Box::new(rawexpr) },<br/></span><span class="s1">            JSExpr::OperatorAdd { lexpr: l, rexpr: r } =&gt; {<br/></span><span class="s1">               let l = eval(*l);<br/></span><span class="s1">               let r = eval(*r);<br/></span><span class="s1">               //call add op codes for possible l,r representations<br/></span><span class="s1">               //should return wrapped value from above<br/></span><span class="s1">               JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">            }<br/></span><span class="s1">            JSExpr::OperatorMul { lexpr: l, rexpr: r } =&gt; {<br/></span><span class="s1">               let l = eval(*l);<br/></span><span class="s1">               let r = eval(*r);<br/></span><span class="s1">               //call mul op codes for possible l,r representations<br/></span><span class="s1">               //should return wrapped value from above<br/></span><span class="s1">               JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Another example of the ADT concept is in heterogeneous lists. Heterogeneous lists are not like other generic containers, such as vectors. Rust vectors are homogeneous, meaning all items are required to have the same type. By comparison, a heterogeneous list can have any mix of types of elements. This may sound like a tuple, but tuples have a fixed length and flat type signature. Similarly, heterogeneous lists must have a length and type signature known at compile time, but that knowledge can be achieved incrementally. Heterogeneous lists are permitted to work with partial knowledge of the list type, parameterizing the knowledge that they do not need.</p>
<p>Here is an example implementation of a heterogeneous list:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait HList: Sized {}<br/><br/></span><span class="s1">pub struct HNil;<br/></span><span class="s1">impl HList for HNil {}<br/></span><span class="s1"><br/>pub struct HCons&lt;H, T&gt; {<br/></span><span class="s1">   pub head: H,<br/></span><span class="s1">   pub tail: T,<br/></span><span class="s1">}<br/></span><span class="s1">impl&lt;H, T: HList&gt; HList for HCons&lt;H, T&gt; {}<br/></span><span class="s1">impl&lt;H, T&gt; HCons&lt;H, T&gt; {<br/></span><span class="s1">   pub fn pop(self) -&gt; (H, T) {<br/></span><span class="s1">      (self.head, self.tail)<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Notice how this definition intentionally uses a trait to obscure type information, without which, such a definition would be impossible. A declaration of an <kbd>HList</kbd> would look like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let hl = HCons {<br/></span><span class="s1">   head: 2,<br/></span><span class="s1">   tail: HCons {<br/></span><span class="s1">      head: "abcd".to_string(),<br/></span><span class="s1">      tail: HNil<br/></span><span class="s1">   }<br/></span><span class="s1">};<br/><br/></span><span class="s1">let (h1,t1) = hl.pop();<br/></span><span class="s1">let (h2,t2) = t1.pop();<br/></span><span class="s1">//this would fail<br/></span><span class="s1">//HNil has no .pop method<br/></span><span class="s1">//t2.pop();</span></pre>
<p>Rust can be a bit rigid with regards to type checking, at times. However, there are also many workarounds that permit complex behavior that might seem impossible at first.</p>


            </article>

            
        </section>
    </body>

</html>