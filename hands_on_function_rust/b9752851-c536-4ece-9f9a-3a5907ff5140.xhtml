<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Summary</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced many common functional design patterns. We used a lot of scary words, such as functor, monad, and combinator. You should try to remember these words and their meanings. Other scary words, such as contravariant, you can probably forget unless you want to pursue math.</p>
<p>In an applied context, we learned that functors can hide information to expose simple transformations on data. The monad pattern allows us to turn sequential actions into units of computation. Monads can be used to create iterators that also behave more like lists. Laziness can be used to defer computation. Also, these patterns can often be combined in useful ways, such as FRP, which is gaining popularity as a tool to develop user interfaces and other complex interactive programs.</p>
<p>In the next chapter, we will explore concurrency. We will introduce the Rust concepts of thread/data ownership, shared synchronized data, and message passing. Thread-level concurrency is something that Rust was specifically designed for. If you have worked with threads in other languages, then hopefully the next chapter will be encouraging.</p>


            </article>

            
        </section>
    </body>

</html>