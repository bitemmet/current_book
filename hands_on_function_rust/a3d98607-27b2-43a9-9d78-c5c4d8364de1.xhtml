<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Using the lazy evaluation pattern</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Using the lazy evaluation pattern</h1>
                </header>
            
            <article>
                
<p>Lazy evaluation is procrastination, doing work later rather than now. Why is this important? Well, it turns out if you procrastinate long enough, sometimes it turns out that the work never needed to be done after all!</p>
<p>Take, for example, a simple expression evaluation:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   2 + 3;<br/><br/></span><span class="s1">   || 2 + 3;<br/></span><span class="s1">}</span></pre>
<p>In a strict interpretation, the first expression will perform an arithmetic calculation. The second expression will define an arithmetic calculation but will wait before evaluating it.</p>
<p>This case is so simple that the compiler gives a warning and might choose to discard the unused constant expression. In more complicated cases, the lazy evaluated case will always perform better when not evaluated. This should be expected because unused lazy expressions do nothing, intentionally.</p>
<p>Iterators are lazy. They don't do anything until you collect or otherwise iterate over them:</p>
<pre class="p1"><span class="s1">fn main() {<br/></span><span class="s1">   let a = (0..10).map(|x| x * x);<br/>   //nothing yet<br/><br/></span><span class="s1">   for x in a {<br/></span><span class="s1">      println!("{}", x);<br/></span></pre>
<pre class="p1"><span class="s1">   }<br/>   //now it ran<br/></span><span class="s1">}</span></pre>
<p>Another data structure that intentionally uses lazy evaluation is the lazy list. A lazy list is very similar to an iterator with the exception that lazy lists can be shared and consumed at different paces independently.</p>
<p>In the parser combinator example, we hid a lazy list inside of the parser state structure. Let's isolate that and see what a pure definition looks like:</p>
<pre class="p1" style="padding-left: 30px">use std::rc::Rc;<span class="s1"><br/><br/></span><span class="s1">#[derive(Clone)]<br/></span><span class="s1">struct LazyList&lt;A: Clone&gt; {<br/></span><span class="s1">   buffer: Rc&lt;Vec&lt;A&gt;&gt;,<br/></span><span class="s1">   index: usize<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;A: Clone&gt; LazyList&lt;A&gt; {<br/></span><span class="s1">   fn new(buf: Vec&lt;A&gt;) -&gt; LazyList&lt;A&gt; {<br/></span><span class="s1">      LazyList {<br/></span><span class="s1">         buffer: Rc::new(buf),<br/></span><span class="s1">         index: 0<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn next(&amp;self) -&gt; Option&lt;(LazyList&lt;A&gt;,A)&gt; {</span><span class="s1"><br/></span><span class="s1">      if self.index &lt; self.buffer.len() {<br/></span><span class="s1">         let new_item = self.buffer[self.index].clone();<br/></span><span class="s1">         let new_index = self.index + 1;<br/></span><span class="s1">         Some((LazyList {<br/></span><span class="s1">            buffer: Rc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: new_index<br/></span><span class="s1">         },new_item))<br/></span><span class="s1">      } else {<br/></span><span class="s1">         None<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   let ll = LazyList::new(vec![1,2,3]);<br/></span><span class="s1">   let (ll1,a1) = ll.next().expect("expect 1 item");<br/></span><span class="s1">   println!("lazy item 1: {}", a1);<br/><br/></span><span class="s1">   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/></span><span class="s1">   println!("lazy item 2: {}", a2);<br/><br/></span><span class="s1">   let (ll3,a3) = ll2.next().expect("expect 3 item");<br/></span><span class="s1">   println!("lazy item 3: {}", a3);<br/></span><span class="s1"><br/>   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/></span><span class="s1">   println!("lazy item 2: {}", a2);<br/></span><span class="s1">}</span></pre>
<p>Here, we can see that a lazy list is much like an iterator. In fact, a lazy list could implement the <kbd>Iterator</kbd> trait; then it really would be an iterator. However, iterators are not lazy lists. Lazy lists inherently have an unlimited capacity to look ahead to any number of items. Iterators, on the other hand, optionally, may implement the <kbd>Peekable</kbd> trait permitting one look ahead.</p>
<p>There is a fundamental problem at the core of lazy programming, though. Too much procrastination will never complete any task. If you write a program to launch missiles, at some point in the program, it needs to actually launch missiles. This is an irreversible side-effect of running the program. We don't like side-effects, and lazy programming takes an extreme stance against side- effects. At the same time, we need to accomplish the given task though, and that involves making a choice at some point to push the launch button.</p>
<p>Clearly, we can never fully contain the behavior of programs with side-effects. However, we can make them easier to work with. By wrapping side-effects into lazy evaluated expressions, then turning them into monads, what we create are side-effect units. These units can then be manipulated and composed in a more functional style.</p>
<p>The last lazy pattern that we will introduce is <strong>functional reactive programming</strong>, <strong>FRP</strong> for short. There are entire programming languages, such as Elm, based on this concept. Popular web UI frameworks, such as React or Angular, are also influenced by FRP concepts.</p>
<p>The FRP concept is an extension of the side-effect/state monad example. Event handling, state transitions, and side-effects can be turned into units of reactive programming. Let's define a monad to capture this reactive unit concept:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct ReactiveUnit&lt;St,A,B&gt; {<br/></span><span class="s1">   state: Arc&lt;Mutex&lt;St&gt;&gt;,<br/></span><span class="s1">   event_handler: Arc&lt;Fn(&amp;mut St,A) -&gt; B&gt;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;St: 'static,A: 'static,B: 'static&gt; ReactiveUnit&lt;St,A,B&gt; {<br/></span><span class="s1">   fn new&lt;F&gt;(st: St, f: F) -&gt; ReactiveUnit&lt;St,A,B&gt;<br/></span><span class="s1">      where F: 'static + Fn(&amp;mut St,A) -&gt; B<br/></span><span class="s1">   {<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::new(Mutex::new(st)),<br/></span><span class="s1">         event_handler: Arc::new(f)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;G,C&gt;(&amp;self, g: G) -&gt; ReactiveUnit&lt;St,A,C&gt;<br/></span><span class="s1">      where G: 'static + Fn(&amp;mut St,B) -&gt; C {<br/></span><span class="s1">      let ev = Arc::clone(&amp;self.event_handler);<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::cl</span>one(&amp;self.state),<span class="s1"><br/></span><span class="s1">         event_handler: Arc::new(move |st: &amp;mut St,a| {<br/></span><span class="s1">            let r = ev(st,a);<br/></span><span class="s1">            let r = g(st,r);<br/></span><span class="s1">            r<br/></span><span class="s1">         })<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn plus&lt;St2: 'static,C: 'static&gt;(&amp;self, other: ReactiveUnit&lt;St2,B,C&gt;) -&gt; ReactiveUnit&lt;(Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),A,C&gt; {<br/></span><span class="s1">      let ev1 = Arc::clone(&amp;self.event_handler);<br/></span><span class="s1">      let st1 = Arc::clone(&amp;self.state);<br/></span><span class="s1">      let ev2 = Arc::clone(&amp;other.event_handler);<br/></span><span class="s1">      let st2 = Arc::clone(&amp;other.state);<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::new(Mutex::new((st1,st2))),<br/></span><span class="s1">         event_handler: Arc::new(move |stst: &amp;mut (Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),a| {<br/></span><span class="s1">            let mut st1 = stst.0.lock().unwrap();<br/></span><span class="s1">            let r = ev1(&amp;mut st1, a);<br/></span><span class="s1">            let mut st2 = stst.1.lock().unwrap();<br/></span><span class="s1">            let r = ev2(&amp;mut st2, r);<br/></span><span class="s1">            r<br/></span><span class="s1">         })<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn apply(&amp;self, a: A) -&gt; B {<br/></span><span class="s1">      let mut st = self.state.lock().unwrap();<br/></span><span class="s1">      (self.event_handler)(&amp;mut st, a)<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Here, we find that a <kbd>ReactiveUnit</kbd> holds state, can respond to an input, cause side-effects, and return a value. Reactive units can be extended with <kbd>bind</kbd> or concatenated with <kbd>plus</kbd>.</p>
<p>Now, let's make a reactive unit. We will focus on web frameworks since those seem to be popular. First, we render a simple HTML page, as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render1 = ReactiveUnit::new((),|(),()| {<br/></span><span class="s1">   let html = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;page content&lt;/div&gt;<br/></span><span class="s1">    &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">  ';"###;<br/></span><span class="s1">  html.to_string()<br/></span><span class="s1">});<br/></span><span class="s1">println!("{}", render1.apply(()));</span></pre>
<p>Here, the unit renders a simple page corresponding to <kbd>section 1</kbd> on a website. The unit will always render a whole page and does not consider any state or input. Let's give the unit more responsibilities by telling it to render different content based on which section is active:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render2 = ReactiveUnit::new((),|(),section: usize| {<br/><br/></span><span class="s1">   let section_1 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 1 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">    ';"###;<br/><br/></span><span class="s1">    let section_2 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 2 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">    ';"###;<br/><br/></span><span class="s1">    let section_3 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 3 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">   ';"###;<br/><br/></span><span class="s1">   if section==1 {<br/></span><span class="s1">      section_1.to_string()<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2.to_string()<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3.to_string()<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic!("unknown section")<br/></span><span class="s1">   }<br/></span>});<br/><br/><span class="s1">println!("{}", render2.apply(1));<br/></span><span class="s1">println!("{}", render2.apply(2));<br/></span><span class="s1">println!("{}", render2.apply(3));</span></pre>
<p>Here, the unit makes use of the parameter to decide what section should be rendered. This is starting to feel more like a UI framework, but we aren't using the state, yet. Let's try using that to address a common web problem—page tearing. When a large portion of HTML is changed on a web page, the browser must recalculate how the page should be displayed. Most modern browsers do this in stages and the result is an ugly mishmash of components being visibly thrown around the page.</p>
<p>To reduce or prevent page tearing, we should only update portions of the page that have changed. Let's use the state variable along with the input parameter to only send updates when a component has changed:</p>
<pre style="padding-left: 30px"><span class="s1">let render3header = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/></span><span class="s1">   let section_1 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_2 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_3 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let changed = if section==1 {<br/></span><span class="s1">      section_1<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic</span>!("invalid section")<span class="s1"><br/></span><span class="s1">   };<br/></span><span class="s1">   if let Some(sec) = *opsec {<br/></span><span class="s1">      if sec==section { "" }<br/></span><span class="s1">      else {<br/></span><span class="s1">         *opsec = Some(section);<br/></span><span class="s1">         changed<br/></span><span class="s1">      }<br/></span>   } else<span class="s1"> {<br/></span><span class="s1">      *opsec = Some(section);<br/></span><span class="s1">      changed<br/></span><span class="s1">   }<br/></span><span class="s1">});<br/></span></pre>
<p>Here, we issue commands to conditionally render changes to the header. If the header is already in the correct state, then we do nothing. This code only takes responsibility for the header component. We also need to render changes to page content:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render3content = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/></span><span class="s1">   let section_1 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 1 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_2 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 2 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_3 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 3 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let changed = if section==1 {<br/></span><span class="s1">      section_1<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic!("invalid section")<br/></span><span class="s1">   };<br/></span><span class="s1">   if let Some(sec) = *opsec {<br/></span><span class="s1">      if sec==section { "" }<br/></span><span class="s1">      else {<br/></span><span class="s1">         *opsec = Some(section);<br/></span><span class="s1">         changed<br/></span><span class="s1">      }<br/></span>   } else<span class="s1"> {<br/></span><span class="s1">      *opsec = Some(section);<br/></span><span class="s1">      changed<br/></span><span class="s1">   }<br/></span><span class="s1">});</span></pre>
<p>Now, we have a component for the header and another component for the content. We should combine these two into a single unit. FRP libraries would probably have a cool neat way of doing this, but we don't; so instead, we just write a little unit to combine them manually:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render3 = ReactiveUnit::new((render3header,render3content), |(rheader,rcontent),section: usize| {<br/></span><span class="s1">   let header = rheader.apply(section);<br/></span><span class="s1">   let content = rcontent.apply(section);<br/></span><span class="s1">   format!("{}{}", header, content)<br/></span><span class="s1">});</span></pre>
<p>Now, let's test this out:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">println!("section 1: {}", render3.apply(1));<br/></span><span class="s1">println!("section 2: {}", render3.apply(2));<br/></span><span class="s1">println!("section 2: {}", render3.apply(2));<br/></span><span class="s1">println!("section 3: {}", render3.apply(3));</span></pre>
<p>Each <kbd>apply</kbd> issues appropriate new update commands. The redundant <kbd>apply</kbd> to render <kbd>section 2</kbd> again returns no commands, as intended. This is really lazy code; the good kind of lazy.</p>
<p>What would reactive programming be without event handling? Let's handle a couple of signals and events. On top of the page state, let's introduce some database interaction:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let database = ("hello world", 5, 2);<br/></span><span class="s1">let react1 = ReactiveUnit::new((database,render3), |(database,render),evt:(&amp;str,&amp;str)| {<br/></span><span class="s1">   match evt {<br/></span><span class="s1">      ("header button click",n) =&gt; render.apply(n.parse::&lt;usize&gt;().unwrap()),<br/></span><span class="s1">      ("text submission",s) =&gt; { database.0 = s; format!("db.textfield1.set(\"{}\")",s) },<br/></span><span class="s1">      ("number 1 submission",n) =&gt; { database.1 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield1.set(\"{}\")",database.1) },<br/></span><span class="s1">      ("number 2 submission",n) =&gt; { database.2 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield2.set(\"{}\")",database.2) },<br/></span><span class="s1">      _ =&gt; "".to_string()<br/></span><span class="s1">   }<br/></span><span class="s1">});<br/><br/></span><span class="s1">println!("react 1: {}", react1.apply(("header button click","2")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("header button click","2")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("text submission","abc def")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 1 submission","123")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 1 submission","234")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 2 submission","333")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 2 submission","222")));</span></pre>
<p>We define four event types to react to. Responding to page state changes still works as previously defined. Events that should interact with the database issue commands to update the database locally and remotely. A view of the output JavaScript looks like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">event: ("header button click", "2")<br/>$('header').innerHTML = '<br/></span><span class="s1">   &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">   &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">   &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">';$('div#content').innerHTML = '<br/></span><span class="s1">   section 2 content<br/></span><span class="s1">';<br/></span><span class="s1"><br/>event: ("header button click", "2")<br/><br/></span><span class="s1">event: ("text submission", "abc def")<br/>db.textfield1.set("abc def")<br/><br/>event: ("number 1 submission", "123")<br/>db.numfield1.set("128")<br/><br/>event: ("number 1 submission", "234")<br/>db.numfield1.set("362")<br/><br/>event: ("number 2 submission", "333")<br/>db.numfield2.set("335")<br/><br/>event: ("number 2 submission", "222")<br/>db.numfield2.set("557")</span></pre>
<p>This correspondence demonstrates how simple side-effect units can be composed to create complex programmatic behavior. This is all built from an FRP library that is less than 50 lines long. Imagine the potential utility of a few more helper functions.</p>


            </article>

            
        </section>
    </body>

</html>