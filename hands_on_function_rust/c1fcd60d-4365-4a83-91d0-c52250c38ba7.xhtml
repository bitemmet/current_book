<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Writing the executable to run a simulation</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Writing the executable to run a simulation</h1>
                </header>
            
            <article>
                
<p>The executable to run a simulation, contained in <kbd>src/lib.rs</kbd>, consists of all input and configuration from the previous chapter's simulation. Here is the harness used to configure and run a simulation:</p>
<pre style="padding-left: 30px">pub fn run_simulation()<br/>{<br/><br/>   //1. Store location, velocity, and acceleration state<br/>   //2. Store motor input voltage<br/>   let mut est = ElevatorState {<br/>      timestamp: 0.0,<br/>      location: 0.0,<br/>      velocity: 0.0,<br/>      acceleration: 0.0,<br/>      motor_input: MotorInput::Up {<br/>         //a positive force is required to counter gravity and<br/>         voltage: 9.8 * (120000.0 / 8.0)<br/>      }<br/>   };<br/><br/>   //3. Store input building description and floor requests<br/>   let mut esp = ElevatorSpecification {<br/>      floor_count: 0,<br/>      floor_height: 0.0,<br/>      carriage_weight: 120000.0<br/>   };<br/>   let mut floor_requests = Vec::new();<br/><br/>   //4. Parse input and store as building description<br/>           and floor requests<br/><span class="s1">   let buffer = match env::args().nth(1) {<br/></span><span class="s1">      Some(ref fp) if *fp == "-".to_string()<span class="Apple-converted-space">  </span>=&gt; {<br/></span><span class="s1">         let mut buffer = String::new();<br/></span><span class="s1">         io::stdin().read_to_string(&amp;mut buffer)<br/></span><span class="s1">                    .expect("read_to_string failed");<br/></span><span class="s1">         buffer<br/></span><span class="s1">      },<br/></span><span class="s1">      None =&gt; {<br/></span><span class="s1">         let fp = "test1.txt";<br/></span><span class="s1">         let mut buffer = String::new();<br/></span><span class="s1">         File::open(fp)<br/></span><span class="s1">              .expect("File::open failed")<br/></span><span class="s1">              .read_to_string(&amp;mut buffer)<br/></span><span class="s1">              .expect("read_to_string failed");<br/></span><span class="s1">         buffer<br/></span><span class="s1">      },<br/></span><span class="s1">      Some(fp) =&gt; {<br/></span><span class="s1">         let mut buffer = String::new();<br/></span><span class="s1">         File::open(fp)<br/></span><span class="s1">              .expect("File::open failed")<br/></span><span class="s1">              .read_to_string(&amp;mut buffer)<br/></span><span class="s1">              .expect("read_to_string failed");<br/></span><span class="s1">         buffer<br/></span><span class="s1">      }<br/></span><span class="s1">   };<br/></span><span class="s1">   for (li,l) in buffer.lines().enumerate() {<br/></span><span class="s1">      if li==0 {<br/></span><span class="s1">         esp.floor_count = l.parse::&lt;u64&gt;().unwrap();<br/></span><span class="s1">      } else if li==1 {<br/></span><span class="s1">         esp.floor_height = l.parse::&lt;f64&gt;().unwrap();<br/></span><span class="s1">      } else {<br/></span><span class="s1">         floor_requests.push(l.parse::&lt;u64&gt;().unwrap());<br/></span><span class="s1">      }<br/></span><span class="s1">   }</span>  </pre>
<p>After establishing the simulation state and reading the input configuration, we run the simulation:</p>
<pre style="padding-left: 30px">   let termsize = termion::terminal_size().ok();<br/>   let mut dr = SimpleDataRecorder {<br/>      esp: esp.clone(),<br/>      termwidth: termsize.map(|(w,_)| w-2).expect("termwidth") <br/>         as u64,<br/>      termheight: termsize.map(|(_,h)| h-2).expect("termheight")<br/>         as u64,<br/>      stdout: &amp;mut io::stdout().into_raw_mode().unwrap(),<br/>      log: File::create("simulation.log").expect("log file"),<br/>      record_location: Vec::new(),<br/>      record_velocity: Vec::new(),<br/>      record_acceleration: Vec::new(),<br/>      record_voltage: Vec::new()<br/>   };<br/>   /*<br/>   let mut mc = SimpleMotorController {<br/>      esp: esp.clone()<br/>   };<br/>   */<br/>   let mut mc = SmoothMotorController {<br/>      timestamp: 0.0,<br/>      esp: esp.clone()<br/>   };<br/><br/>   simulate_elevator(esp, est, floor_requests, &amp;mut mc, &amp;mut dr);<br/>   dr.summary();<br/><br/>}</pre>
<p>The <kbd>DataRecorder</kbd> implementation, also in <kbd>src/lib.rs</kbd>, is responsible for outputting real-time information as well as summary information. Additionally, we will serialize and store the simulation data in a log file. Notice the use of the <kbd>lifetime</kbd> parameter along with the parameterized <kbd>trait</kbd>:</p>
<pre style="padding-left: 30px">struct SimpleDataRecorder&lt;'a, W: 'a + Write&gt;<br/>{<br/>   esp: ElevatorSpecification,<br/>   termwidth: u64,<br/>   termheight: u64,<br/>   stdout: &amp;'a mut raw::RawTerminal&lt;W&gt;,<br/>   log: File,<br/>   record_location: Vec&lt;f64&gt;,<br/>   record_velocity: Vec&lt;f64&gt;,<br/>   record_acceleration: Vec&lt;f64&gt;,<br/>   record_voltage: Vec&lt;f64&gt;,<br/>}<br/>impl&lt;'a, W: Write&gt; DataRecorder for SimpleDataRecorder&lt;'a, W&gt;<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState)<br/>   {<br/>      self.esp = esp.clone();<br/>      self.log.write_all(serde_json::to_string(&amp;esp).unwrap().as_bytes()).expect("write spec to log");<br/>      self.log.write_all(b"\r\n").expect("write spec to log");<br/>   }<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64)<br/>   {<br/>      let datum = (est.clone(), dst);<br/>      self.log.write_all(serde_json::to_string(&amp;datum).unwrap().as_bytes()).expect("write state to log");<br/>      self.log.write_all(b"\r\n").expect("write state to log");<br/><br/>      self.record_location.push(est.location);<br/>      self.record_velocity.push(est.velocity);<br/>      self.record_acceleration.push(est.acceleration);<br/>      self.record_voltage.push(est.motor_input.voltage());</pre>
<p>The <kbd>DataRecorder</kbd> is responsible for not only recording simulation data to logs, but also for printing statistics to the Terminal:</p>
<pre style="padding-left: 30px">      //5.4. Print realtime statistics<br/>      print!("{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Hide);<br/>      let carriage_floor = (est.location / self.esp.floor_height).floor();<br/>      let carriage_floor = if carriage_floor &lt; 1.0 { 0 } else { carriage_floor as u64 };<br/>      let carriage_floor = cmp::min(carriage_floor, self.esp.floor_count-1);<br/>      let mut terminal_buffer = vec![' ' as u8; (self.termwidth*self.termheight) as usize];<br/>      for ty in 0..self.esp.floor_count<br/>      {<br/>         terminal_buffer[ (ty*self.termwidth + 0) as usize ] = '[' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + 1) as usize ] =<br/>            if (ty as u64)==((self.esp.floor_count-1)-carriage_floor) { 'X' as u8 }<br/>            else { ' ' as u8 };<br/>         terminal_buffer[ (ty*self.termwidth + 2) as usize ] = ']' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + self.termwidth-2) as usize ] = '\r' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + self.termwidth-1) as usize ] = '\n' as u8;<br/>      }<br/>      let stats = vec![<br/>         format!("Carriage at floor {}", carriage_floor+1),<br/>         format!("Location {:.06}", est.location),<br/>         format!("Velocity {:.06}", est.velocity),<br/>         format!("Acceleration {:.06}", est.acceleration),<br/>         format!("Voltage [up-down] {:.06}", est.motor_input.voltage()),<br/>      ];<br/>      for sy in 0..stats.len()<br/>      {<br/>         for (sx,sc) in stats[sy].chars().enumerate()<br/>         {<br/>            terminal_buffer[ sy*(self.termwidth as usize) + 6 + sx ] = sc as u8;<br/>         }<br/>      }<br/>      write!(self.stdout, "{}",</pre>
<pre style="padding-left: 30px">String::from_utf8(terminal_buffer).ok().unwrap());<br/>      self.stdout.flush().unwrap();<br/>   }</pre>
<p>The <kbd>DataRecorder</kbd> is also responsible for printing a summary at the end of the simulation:</p>
<pre style="padding-left: 30px">   fn summary(&amp;mut self)<br/>   {<br/>      //6 Calculate and print summary statistics<br/>      write!(self.stdout, "{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();<br/>      variable_summary(&amp;mut self.stdout, "location".to_string(), &amp;self.record_location);<br/>      variable_summary(&amp;mut self.stdout, "velocity".to_string(), &amp;self.record_velocity);<br/>      variable_summary(&amp;mut self.stdout, "acceleration".to_string(), &amp;self.record_acceleration);<br/>      variable_summary(&amp;mut self.stdout, "voltage".to_string(), &amp;self.record_voltage);<br/>      self.stdout.flush().unwrap();<br/>   }<br/>}</pre>


            </article>

            
        </section>
    </body>

</html>