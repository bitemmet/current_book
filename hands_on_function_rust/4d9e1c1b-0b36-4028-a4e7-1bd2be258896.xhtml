<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Metaprogramming</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Metaprogramming</h1>
                </header>
            
            <article>
                
<p>Metaprogramming in Rust has two forms—macros and procedural macros. Both of these utilities accept an abstract syntax tree as new input and output symbols to be compiled. Procedural macros are very similar to normal macros but with fewer restrictions on how they work and how they are defined.</p>
<p>Macros defined with the <kbd>macro_rules!</kbd> syntax are defined recursively by matching the input syntax to produce output. It is crucial to understand that macro matching happens <em>after</em> parsing. This means the following:</p>
<ul>
<li>Macros must follow certain rules when creating new syntax forms</li>
<li>The AST is decorated with information regarding each node's grammar category</li>
</ul>
<p>Macros can match individual tokens, or a macro can match (and capture) an entire grammar category. The Rust grammar categories are as follows:</p>
<ul>
<li><kbd>tt</kbd>: This is a token tree (which is a token output from the lexer before parsing)</li>
<li><kbd>ident</kbd>: This is an identifier</li>
<li><kbd>expr</kbd>: This is an expression</li>
<li><kbd>ty</kbd>: This is a type</li>
<li><kbd>stmt</kbd>: This is a statement</li>
<li><kbd>block</kbd>: These are the braces containing a block of statements</li>
<li><kbd>item</kbd>: This is a top-level definition such as a function or a struct</li>
<li><kbd>pat</kbd>: This is the match part of a pattern match expression, also called the <strong>left hand side</strong></li>
<li><kbd>path</kbd>: This is a path such as <kbd>std::fs::File</kbd></li>
<li><kbd>meta</kbd>: This is a meta item that goes inside either <kbd>#[...]</kbd> or <kbd>#![...]</kbd> syntax forms</li>
</ul>
<p>Using these patterns we can create macros to match various groups of syntax expressions:</p>
<pre class="p1"><span class="s1">//This macro rule matches one token tree "tt"<br/>macro_rules! match_tt {<br/></span><span class="s1">   ($e: tt) =&gt; { println!("match_tt: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one identifier "ident"<br/></span><span class="s1">macro_rules! match_ident {<br/></span><span class="s1">   ($e: ident) =&gt; { println!("match_ident: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one expression "expr"<br/></span><span class="s1">macro_rules! match_expr {<br/></span><span class="s1">   ($e: expr) =&gt; { println!("match_expr: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one type "ty" <br/></span><span class="s1">macro_rules! match_ty {<br/></span><span class="s1">   ($e: ty) =&gt; { println!("match_ty: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one statement "stmt"<br/></span><span class="s1">macro_rules! match_stmt {<br/></span><span class="s1">   ($e: stmt) =&gt; { println!("match_stmt: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one block "block"<br/></span><span class="s1">macro_rules! match_block {<br/></span><span class="s1">   ($e: block) =&gt; { println!("match_block: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one item "item"<br/>//items are things like function definitions, struct definitions, ...<br/></span><span class="s1">macro_rules! match_item {<br/></span><span class="s1">   ($e: item) =&gt; { println!("match_item: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one pattern "pat"<br/></span><span class="s1">macro_rules! match_pat {<br/></span><span class="s1">   ($e: pat) =&gt; { println!("match_pat: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one path "path"<br/>//A path is a canonical named path like std::fs::File<br/></span><span class="s1">macro_rules! match_path {<br/></span><span class="s1">   ($e: path) =&gt; { println!("match_path: {}", stringify!($e)) }<br/></span><span class="s1">}<br/><br/>//This macro rule matches one meta "meta"<br/>//A meta is anything inside of the #[...] or #![...] syntax<br/></span><span class="s1">macro_rules! match_meta {<br/></span><span class="s1">   ($e: meta) =&gt; { println!("match_meta: {}", stringify!($e)) }<br/></span><span class="s1">}</span></pre>
<p>Then, let's apply the macros to some different input:</p>
<pre class="p1"><span class="s1">fn main() {<br/></span><span class="s1">   match_tt!(a);<br/></span><span class="s1">   match_tt!(let);<br/></span><span class="s1">   match_tt!(+);<br/><br/></span><span class="s1">   match_ident!(a);<br/></span><span class="s1">   match_ident!(bcd);<br/></span><span class="s1">   match_ident!(_def);<br/><br/></span><span class="s1">   match_expr!(1.2);<br/></span><span class="s1">   match_expr!(bcd);<br/></span><span class="s1">   match_expr!(1.2 + bcd / "b" - [1, 3, 4] .. vec![1, 2, 3]);<br/><br/></span><span class="s1">   match_ty!(A);<br/></span><span class="s1">   match_ty!(B + 'static);<br/></span><span class="s1">   match_ty!(A&lt;&amp;(B + 'b),&amp;mut (C + 'c)&gt; + 'static);<br/><br/></span><span class="s1">   match_stmt!(let x = y);<br/></span><span class="s1">   match_stmt!(());<br/></span><span class="s1">   match_stmt!(fn f(){});<br/></span><span class="s1">   <br/>   match_block!({});<br/></span><span class="s1">   match_block!({1; 2});<br/></span><span class="s1">   match_block!({1; 2 + 3});<br/><br/></span><span class="s1">   match_item!(struct A(u64););<br/></span><span class="s1">   match_item!(enum B { C, D });<br/></span><span class="s1">   match_item!(fn C(n: NotAType) -&gt; F&lt;F&lt;F&lt;F&lt;F&gt;&gt;&gt;&gt; { a + b });<br/><br/></span><span class="s1">   match_pat!(_);<br/></span><span class="s1">   match_pat!(1);<br/></span><span class="s1">   match_pat!(A {b, c:D( d@3 )} );<br/><br/></span><span class="s1">   match_path!(A);<br/></span><span class="s1">   match_path!(::A);<br/></span><span class="s1">   match_path!(std::A);<br/></span><span class="s1">   match_path!(a::&lt;A,_&gt;);<br/><br/></span><span class="s1">   match_meta!(A);<br/></span><span class="s1">   match_meta!(Property(B,C));<br/></span><span class="s1">}</span></pre>
<p>As we can see from the example, token trees are, for the most part, not restricted to normal Rust grammar, only to the Rust lexer. The lexer is aware of opening and closing <kbd>() [] {}</kbd> bracketed forms. This is why tokens are structured in a token tree rather than a token list. This also means that all tokens inside macro calls will be stored as token trees and not processed any further until the macro is invoked; as long as we create a syntax compatible with Rust token trees, then other syntax innovations should usually be permitted. This rule applies also to the other grammar categories: grammar categories are just a short hand to match certain pattern of tokens that happen to correspond to Rust syntax forms.</p>
<p>Just matching single tokens or grammar categories probably won't be very useful for a macro. To make use of macros in a practical context, we will need to make use of macro grammar sequences and grammar alternative<em>s</em>. A grammar sequence is a request to match more than one token or grammar category in the same rule. A grammar alternative is a separate rule within the same macro that matches a different syntax. Grammar sequences and alternatives can also be combined in the same macro. Additionally, there is a special syntax form to match <em>many</em> tokens or grammar categories.</p>
<p>Here are corresponding examples to illustrate these patterns:</p>
<pre class="p1"><span class="s1">//this is a grammar sequence<br/></span><span class="s1">macro_rules! abc {<br/></span><span class="s1">   (a b c) =&gt; { println!("'a b c' is the only correct syntax.") };<br/></span><span class="s1">}<br/><br/></span><span class="s1">//this is a grammar alternative<br/></span><span class="s1">macro_rules! a_or_b {<br/></span><span class="s1">   (a) =&gt; { println!("'a' is one correct syntax.") };<br/></span><span class="s1">   (b) =&gt; { println!("'b' is also correct syntax.") };<br/></span><span class="s1">}<br/><br/></span><span class="s1">//this is a grammar of alternative sequences<br/></span><span class="s1">macro_rules! abc_or_aaa {<br/></span><span class="s1">   (a b c) =&gt; { println!("'a b c' is one correct syntax.") };<br/></span><span class="s1">   (a a a) =&gt; { println!("'a a a' is also correct syntax.") };<br/></span><span class="s1">}<br/><br/></span><span class="s1">//this is a grammar sequence matching many of one token<br/></span><span class="s1">macro_rules! many_a {<br/></span><span class="s1">   ( $($a:ident)* ) =&gt; {{ $( print!("one {} ", stringify!($a)); )* println!(""); }};<br/></span><span class="s1">   ( $($a:ident),* ) =&gt; {{ $( print!("one {} comma ", stringify!($a)); )* println!(""); }};<br/></span><span class="s1">}</span><span class="s1"><br/><br/></span><span class="s1">fn main() {<br/></span><span class="s1">   abc!(a b c);<br/><br/></span><span class="s1">   a_or_b!(a);<br/></span><span class="s1">   a_or_b!(b);<br/></span><span class="s1"><br/>   abc_or_aaa!(a b c);<br/></span><span class="s1">   abc_or_aaa!(a a a);<br/><br/></span><span class="s1"><span class="Apple-converted-space">   </span>many_a!(a a a);<br/></span><span class="s1"><span class="Apple-converted-space">   </span>many_a!(a, a, a);</span><span class="s1"><br/></span><span class="s1">}</span></pre>
<p>If you've paid attention to the generated code for all of these macros, you might have noticed that all production rules have created expressions. Macro input can be tokens, but output must be a contextually well-formed Rust syntax. For this reason, you cannot write <kbd>macro_rules!</kbd> as shown here:</p>
<pre class="p1"><span class="s1">macro_rules! f {<br/></span><span class="s1">   () =&gt; { f!(1) f!(2) f!(3) };<br/></span><span class="s1">   (1) =&gt; { 1 };<br/></span><span class="s1">   (2) =&gt; { + };<br/></span><span class="s1">   (3) =&gt; { 2 };<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn main() {<br/></span><span class="s1">   f!()<br/></span><span class="s1">}</span></pre>
<p>The specific error from the compiler is as follows:</p>
<pre class="p1"><span class="s1">error</span><span class="s2">: macro expansion ignores token `f` and any following<br/></span>--&gt; <span class="s2">t.rs:2:19<br/></span><span class="s3">  |<br/></span><span class="s3">2</span><span class="s2"> </span><span class="s3">| </span><span class="s2"> <span class="Apple-converted-space">  </span>() =&gt; { f!(1); f!(2); f!(3) };<br/></span><span class="s3">  | </span><span class="s2"><span class="Apple-converted-space">                  </span></span><span class="s1">^<br/></span><span class="s3">  |<br/></span><span class="s4">note</span><span class="s2">: caused by the macro expansion here; the usage of `f!` is likely invalid in expression context<br/></span>--&gt; <span class="s2">t.rs:9:4<br/></span><span class="s3">  |<br/></span><span class="s3">9</span><span class="s2"> </span><span class="s3">| </span><span class="s2"> <span class="Apple-converted-space">  </span>f!()<br/></span><span class="s3">  | </span><span class="s2"> <span class="Apple-converted-space">  </span></span><span class="s4">^^^^<br/><br/></span><span class="s1">error</span><span class="s2">: aborting due to previous error</span></pre>
<p>The key phrase here is <kbd>f!</kbd>, which is likely invalid in an expression context. Each pattern of <kbd>macro_rules!</kbd> output must be a well-formed expression. The preceding example will create well-formed Rust syntax in the end, but its intermediate results are fragmented expressions. This awkwardness is one of the several reasons to use procedural macros, which are much like <kbd>macro_rules!</kbd> but programmed directly in Rust rather than through the special <kbd>macro_rules!</kbd> syntax.</p>
<p>Procedural macros are programmed in Rust, but are also used to compile Rust programs. How does that work? Procedural macros must be isolated into their own modules and compiled separately; they are basically a compiler plugin.</p>
<p>To start our procedural macro, let's create a new subproject:</p>
<ol>
<li>Make a <kbd>procmacro</kbd> <span>directory </span>inside the project root</li>
<li>Inside the <kbd>procmacro</kbd> directory, create a <kbd>Cargo.toml</kbd> file with the following contents:</li>
</ol>
<pre class="p1" style="padding-left: 30px"><span class="s1">[package]<br/></span><span class="s1">name = "procmacro"<br/></span><span class="s1">version = "1.0.0"<br/></span><span class="s1"><br/>[dependencies]<br/></span><span class="s1">syn = "0.12"<br/></span><span class="s1">quote = "0.4"<br/><br/></span><span class="s1">[lib]<br/></span><span class="s1">proc-macro = true</span></pre>
<ol start="3">
<li>Inside the <kbd>procmacro</kbd> directory, create a <kbd>src/lib.rs</kbd> file with the following contents:</li>
</ol>
<pre class="p1" style="padding-left: 30px"><span class="s1">#![feature(proc_macro)]<br/></span><span class="s1">#![crate_type = "proc-macro"]<br/></span><span class="s1">extern crate proc_macro;<br/></span><span class="s1">extern crate syn;<br/></span><span class="s1">#[macro_use] extern crate quote;<br/></span><span class="s1">use proc_macro::TokenStream;<br/></span><span class="s1">#[proc_macro]<br/><br/></span><span class="s1">pub fn f(input: TokenStream) -&gt; TokenStream {<br/></span><span class="s1">   assert!(input.is_empty());<br/><br/></span><span class="s1">   (quote! {<br/></span><span class="s1">      1 + 2<br/></span><span class="s1">   }).into()<br/></span><span class="s1">}</span></pre>
<p style="padding-left: 30px">This <kbd>f!</kbd> macro now implements the preceding semantics without any of the complaints. Using the macro looks like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#![feature(proc_macro_non_items)]<br/></span><span class="s1">#![feature(use_extern_macros)]<br/></span><span class="s1">extern crate procmacro;<br/><br/></span><span class="s1">fn main() {<br/></span><span class="s1">   let _ = procmacro::f!();<br/></span><span class="s1">}</span></pre>
<p>The interface of a procedural macro is really simple. There is a <kbd>TokenStream</kbd> as input and a <kbd>TokenStream</kbd> as output. The <kbd>proc_macro</kbd> and <kbd>syn</kbd> crates also provide utilities to parse tokens or to easily create token streams using the <kbd>quote!</kbd> macro. To use procedural macros, there is some additional setup and boilerplate, but after getting past these hurdles the interface is fairly straightforward now.</p>
<p>Additionally, there are many more detailed grammar categories available to procedural macros through the <kbd>syn</kbd> crate. There are 163 categories (<a href="https://dtolnay.github.io/syn/syn/#macros">https://dtolnay.github.io/syn/syn/#macros</a>) right now! These include the same vague syntax trees from recursive macros, but also very specific syntax forms. These categories correspond to the full Rust grammar, therefore permitting very expressive macro syntax without having to create your own parser.</p>
<p>Let's make a procedural macro that uses some of these syntax categories. First we make a new procedural macro folder, just like preceding <kbd>procmacro</kbd>; this one we will name <kbd>procmacro2</kbd>. Now we define the AST that will hold all of the program information if the user input is valid:</p>
<pre class="p1"><span class="s1">#![feature(proc_macro)]<br/></span><span class="s1">#![crate_type = "proc-macro"]<br/></span><span class="s1">extern crate proc_macro;<br/></span><span class="s1">#[macro_use] extern crate syn;<br/></span><span class="s1">#[macro_use] extern crate quote;<br/></span><span class="s1">use proc_macro::TokenStream;<br/></span><span class="s1">use syn::{Ident, Type, Expr, WhereClause, TypeSlice, Path};<br/></span><span class="s1">use syn::synom::Synom;<br/><br/></span><span class="s1">struct MiscSyntax {<br/></span><span class="s1">   id: Ident,<br/></span><span class="s1">   ty: Type,<br/></span><span class="s1">   expr: Expr,<br/></span><span class="s1">   where_clause: WhereClause,<br/></span><span class="s1">   type_slice: TypeSlice,<br/></span><span class="s1">   path: Path<br/></span><span class="s1">}</span></pre>
<p>The <kbd>MiscSyntax</kbd> struct will contain all information gathered from our macro. That macro and its syntax is what we should define now:</p>
<pre class="p1"><span class="s1">impl Synom for MiscSyntax {<br/></span><span class="s1">   named!(parse -&gt; Self, do_parse!(<br/></span><span class="s1">      keyword!(where) &gt;&gt;<br/></span><span class="s1">      keyword!(while) &gt;&gt;<br/></span><span class="s1">      id: syn!(Ident) &gt;&gt;<br/></span><span class="s1">      punct!(:) &gt;&gt;<br/></span><span class="s1">      ty: syn!(Type) &gt;&gt;<br/></span><span class="s1">      punct!(&gt;&gt;) &gt;&gt;<br/></span><span class="s1">      expr: syn!(Expr) &gt;&gt;<br/></span><span class="s1">      punct!(;) &gt;&gt;<br/></span><span class="s1">      where_clause: syn!(WhereClause) &gt;&gt;<br/></span><span class="s1">      punct!(;) &gt;&gt;<br/></span><span class="s1">      type_slice: syn!(TypeSlice) &gt;&gt;<br/></span><span class="s1">      punct!(;) &gt;&gt;<br/></span><span class="s1">      path: syn!(Path) &gt;&gt;<br/></span><span class="s1">      (MiscSyntax { id, ty, expr, where_clause, type_slice, path })<br/></span><span class="s1">   ));<br/></span><span class="s1">}</span></pre>
<p>The <kbd>do_parse!</kbd> macro helps simplify the use of the parser combinators from the <kbd>syn</kbd> crate. The <kbd>id: expr &gt;&gt;</kbd> syntax corresponds to the monadic bind operation, and <kbd>expr &gt;&gt;</kbd> syntax is also a form of a monadic bind.</p>
<p>Now we utilize these definitions to parse input, generate output, <span>and expose the macro</span>:</p>
<pre class="p1"><span class="s1">#[proc_macro]<br/></span><span class="s1">pub fn misc_syntax(input: TokenStream) -&gt; TokenStream {<br/></span><span class="s1">   let m: MiscSyntax = syn::parse(input).expect("expected Miscellaneous Syntax");<br/></span><span class="s1">   let MiscSyntax { id, ty, expr, where_clause, type_slice, path } = m;<br/></span><span class="s1"><br/>   (quote! {<br/></span><span class="s1">      let #id: #ty = #expr;<br/></span><span class="s1">      println!("variable = {}", #id);<br/></span><span class="s1">    }).into()<br/></span><span class="s1">}</span></pre>
<p>When using this macro, it really is a bunch of random syntax. This emphasizes how macros are not limited to valid Rust syntax, which looks like the following:</p>
<pre class="p1"><span class="s1">#![feature(proc_macro_non_items)]<br/></span><span class="s1">#![feature(use_extern_macros)]<br/></span><span class="s1">extern crate procmacro2;<br/><br/></span><span class="s1">fn main() {<br/></span><span class="s1">   procmacro2::misc_syntax!(<br/></span><span class="s1">      where while abcd : u64 &gt;&gt; 1 + 2 * 3;<br/>      where T: 'x + A&lt;B='y+C+D&gt;;<br/>      [M];A::f<br/></span><span class="s1">   );<br/></span><span class="s1">}</span></pre>
<p>Procedural macros are very powerful and helpful if Rust syntax becomes annoying for your purposes. For specific contexts it is possible to create very semantically dense code using macros that would otherwise require lots of boilerplate and copy-paste coding.</p>


            </article>

            
        </section>
    </body>

</html>