<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>Parametric traits and implementations</title>
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
        <meta charset="utf-8"/>
<meta content="urn:uuid:dd0ab1fe-cf2d-4e17-8acb-531b7ebebf1a" name="Adept.expected.resource"/>
    </head>

    <body>
        <section>

                            <header>
                    <h1 class="header-title">Parametric traits and implementations</h1>
                </header>
            
            <article>
                
<p>Now, we have successfully implemented <kbd>Motor</kbd> and <kbd>MotorInput</kbd> as trait objects. However, we sacrificed nice things like <kbd>Clone</kbd>, <kbd>Serialize</kbd>, <kbd>Deserialize</kbd>, and <kbd>Debug</kbd> to accomplish this. Can we reclaim those functionalities?</p>
<p>First, let's try to duplicate the functionality. We will call these bundled traits <kbd>ElevatorStateClone</kbd> and <kbd>ElevatorSpecificationClone</kbd>. The signatures should look something like the following (the trait implementations are available in the <kbd>src/physics.rs</kbd> file):</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait ElevatorStateClone<br/></span><span class="s1">{</span><span class="s1"><br/></span><span class="s1">   fn clone(&amp;self) -&gt; ElevatorState;<br/></span><span class="s1">   fn dump(&amp;self) -&gt; (f64,f64,f64,f64,f64);<br/></span><span class="s1">   fn load((f64,f64,f64,f64,f64)) -&gt; ElevatorState;<br/></span><span class="s1">}</span><span class="s1"><br/><br/></span><span class="s1">pub trait ElevatorSpecificationClone<br/></span><span class="s1">{<br/></span><span class="s1">   fn clone(&amp;self) -&gt; ElevatorSpecification;<br/></span><span class="s1">   fn dump(&amp;self) -&gt; (u64,f64,f64,u64);<br/></span><span class="s1">   fn load((u64,f64,f64,u64)) -&gt; ElevatorSpecification;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl ElevatorStateClone for ElevatorState {<br/>   ...<br/>}</span></pre>
<p>These traits provide the bare minimum functionality to get us back to where we were previously with serialization and copy semantics. The major downside is that each definition is quite verbose. Additionally, the serialization turns into a tuple, rather than going directly back and forth between the correct type.</p>
<p>So, what precisely is the problem with trait objects? We know that they must be wrapped in <kbd>Box</kbd> types to circumvent the unknown size. Is this the problem? Here is a program to test this theory:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct Foo<br/></span><span class="s1">{<br/></span><span class="s1">   bar: Box&lt;u64&gt;<br/></span><span class="s1">}</span></pre>
<p>So, <kbd>Box</kbd> types can be serialized. The problem, then, must be with the trait object. Let's try the same thing with a trait object to see what happens:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">trait T {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct S1;<br/></span><span class="s1">impl T for S1 {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct S2;<br/></span><span class="s1">impl T for S2 {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct Container<br/></span><span class="s1">{<br/></span><span class="s1">   field: Box&lt;T&gt;<br/></span><span class="s1">}</span></pre>
<p>When compiling this last snippet, we get the error, <kbd>the trait `serde::Deserialize&lt;'_&gt;` is not implemented for `T`</kbd><span>. </span><span>So, we can see that the individual structs <kbd>S1</kbd> and <kbd>S2</kbd> both implement <kbd>Deserialize</kbd>, but that information is obscured. The</span> trait <span>object <kbd>T</kbd> itself must implement</span> <kbd>Deserialize</kbd><span>.</span></p>
<p>Making the first attempt at serializing the trait object <kbd>T</kbd>, we can follow the instructions for writing custom serialization. The result should be something like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl Serialize for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br/></span><span class="s1">   where S: Serializer<br/></span><span class="s1">   {<br/></span><span class="s1">      serializer.serialize_unit_struct("S1")<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">struct S1Visitor;<br/></span><span class="s1">impl&lt;'de&gt; Visitor&lt;'de&gt; for S1Visitor {<br/></span><span class="s1">   type Value = Box&lt;T&gt;;<br/><br/></span><span class="s1">   fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result<br/>   {<br/></span><span class="s1">      formatter.write_str("an S1 structure")<br/></span><span class="s1">   }<br/></span><span class="s1">   fn visit_unit&lt;E&gt;(self) -&gt; Result&lt;Self::Value, E&gt;<br/></span><span class="s1">   where E: de::Error</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">   {<br/></span><span class="s1">      Result::Ok(Box::new(S1))<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;'de&gt; Deserialize&lt;'de&gt; for Box&lt;T&gt; {<br/></span><span class="s1">   fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Box&lt;T&gt;, D::Error&gt;<br/></span><span class="s1">   where D: Deserializer&lt;'de&gt;<br/></span><span class="s1">   {<br/></span><span class="s1">      deserializer.deserialize_unit_struct("S1", S1Visitor)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">let bt: Box&lt;T&gt; = Box::new(S1);<br/></span><span class="s1">let s = serde_json::to_string(&amp;bt).unwrap();<br/></span><span class="s1">let bt: Box&lt;T&gt; = serde_json::from_str(s.as_str()).unwrap();</span></pre>
<p>This is a bit of a mess, but the important parts are that we want to write <kbd>S1</kbd> or <kbd>S2</kbd> to the serializer and check for those tags to deserialize. Essentially, what we are trying to create is a side enum to exist just for the purpose of serialization. Somehow, the serializer needs to know whether <kbd>T</kbd> is an <kbd>S1</kbd> or <kbd>S2</kbd> through the interface, so why not, in turn, provide a method on <kbd>T</kbd> that will return an enum? Enums are also serializable with macros, so we could pass that automatic serialization through to <kbd>T</kbd>. Let's try that, starting with the type and trait definitions, as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/>enum T_Enum<br/></span><span class="s1">{<br/></span><span class="s1">   S1(S1),<br/></span><span class="s1">   S2(S2),<br/></span><span class="s1">}<br/><br/></span><span class="s1">trait T<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum;<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/></span><span class="s1">struct S1;<br/></span><span class="s1">impl T for S1<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum<br/></span><span class="s1">   {<br/></span><span class="s1">      T_Enum::S1(self.clone())<br/></span><span class="s1">   }</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">}</span><span class="s1"><br/></span><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/></span><span class="s1">struct S2;<br/></span><span class="s1">impl T for S2<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum<br/></span><span class="s1">   {<br/></span><span class="s1">      T_Enum::S2(self.clone())<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Here, we can see that there is no issue in permitting a method on a trait object that turns the object into an enum. This relation is natural and provides an escape hatch to convert back and forth between the trait objects and its internal representation. Now, to implement serialization, we just need to wrap and unwrap the enum serializers:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl Serialize for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br/></span><span class="s1">   where S: Serializer<br/></span><span class="s1">   {<br/></span><span class="s1">      self.as_enum().serialize(serializer)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;'de&gt; Deserialize&lt;'de&gt; for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Box&lt;T&gt;, D::Error&gt;<br/></span><span class="s1">   where D: Deserializer&lt;'de&gt;<br/></span><span class="s1">   {<br/></span><span class="s1">      let result = T_Enum::deserialize(deserializer);<br/></span><span class="s1">      match result<br/></span><span class="s1">      {<br/></span><span class="s1">         Result::Ok(te) =&gt; {<br/></span><span class="s1">            match te {<br/></span><span class="s1">               T_Enum::S1(s1) =&gt; Result::Ok(Box::new(s1.clone())),<br/></span><span class="s1">               T_Enum::S2(s2) =&gt; Result::Ok(Box::new(s2.clone()))<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">         Result::Err(err) =&gt; Result::Err(err)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>That wasn't so bad, was it? With this technique, we can hide parameters behind trait objects while still benefiting from the direct access to data and macro-derived traits. There is a little bit of boilerplate here. Luckily though, for each macro, the code is almost identical for whatever type you are using. Remember this one; it could be useful.</p>


            </article>

            
        </section>
    </body>

</html>